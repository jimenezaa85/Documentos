DevOps Skills for Developers with Visual Studio and TFS 2017


It worked cross-platform. But, really, who are we kidding? 
It was for Visual Studio developers. Now let's fast forward to now. 
Let's think about Team Foundation Server 2018. 
It's the current version of on-premises TFS. 
It's got source control, and it's got the same source control that TFS 2005 had, TFVC, Team Foundation Version Control. 
It also has Git. So we've added Git, big addition to the product. 
It's got automated builds, but the automated build system we have now is on its third rewrite. 
So you figure that's 13 years, three versions. It was time for a couple of upgrades. 
The current version I really like a lot. We've got automated releases that are built in to the product, and this is the second version of this. 
It's a lot better than it used to be. It's really good. We've got QA testing and defect tracking tools. 
So basically manage and run manual test cases, and you do that using the web. We also have project management tools, so if you're using Agile and Scrum to manage your project, or you're doing Kanban or Waterfall or CMMI or whatever you happen to be using, you can use TFS to manage your project. We've also got dashboards. Thankfully dashboards don't rely on SQL Server Reporting Services or SharePoint anymore. It makes everyone's lives a lot easier. We've got this whole framework for extensions and integrations. And pretty much everything that you do has moved to the web. So everything moving to the web is great because TFS 2018 is super cross-platform. Almost everything runs out of the browser. So it works great with Visual Studio if you're running on Windows. Cool! But not everyone is running on Windows, and not everyone's using Visual Studio. It supports Visual Studio Code, which exists on three different operating systems, so Windows, Mac OS, and Linux. We've got Visual Studio for Mac now, which is pretty awesome. TFS 2018 has a plugin for Eclipse, IntelliJ, Android Studio, Xcode, Xamarin, cross-platform command line client stuff. It works with Jenkins. And really the biggest thing and the most profound change in the tool is support for Git. Git seems to be where version control is and where version control is heading. So since TFS talks to Git, any tool that talks to Git can talk to Team Foundation Server now. Kind of awesome, kind of handy. Now just to drive this home, TFS is cross-platform. It's super cross-platform. Microsoft is trying to get it so that anybody can use TFS and use it with whatever tools you happen to have. Put another way, TFS is a lot more than just version control, so that whole mindset of "TFS is just version control," or "VSTS is just version control" is wrong, and here's why. TFS does a lot. It runs your projects, tracks your work, tracks your teams and what they're doing, helps you to test your code, gives you build and release, so automated builds, automated releases, and the idea is that it's one place for everything. So whatever you're developing or whatever software efforts you're managing or working with, everything goes in TFS, and it's in there. It's one place, not a whole bunch of places. And you can relate everything to everything else, which is really kind of awesome for traceability, auditability, and for DevOps. DevOps, huge thing, huge focus in Team Foundation Server. DevOps is trying to get you automated deploys, be able to go faster, take a lot of the pain and annoying boring stuff out of your software delivery pipelines. So TFS does all that stuff. Great! Now, back to VSTS is TFS in the cloud, and it's mostly accurate. And it's mostly accurate because, well, VSTS is TFS++. So, it is TFS in the cloud, and then it's also more than just TFS in the cloud. So pretty much whatever you love for your on-premises TFS, VSTS can do that and then more. So next up: We're going to talk more detail about why is VSTS more than just TFS in the cloud? 

Why Is VSTS More Than Just TFS in the Cloud?
So VSTS is more than just TFS in the cloud. 
Put another way, it's cloud-based and TFS-ish. 
So it's kind of like TFS, but it's in the cloud. It does more than just what TFS does. 
But having it in the cloud means that it lets Microsoft do things differently. 
So TFS is packaged software. 
Not it's not literally packaged software anymore. 
That's not really how we do things. 
But they have to bring all their stuff together, and they ship it to you at one time. 
And the on-premises version of TFS does basically about one giant release per year, and then historically, it's been about three or four updates in a year. 
And if you think about it, considering how complex that is, it's a minor miracle, people. 
Let's think about what we had between TFS 2005 and TFS 2008. 
So between the first version and the second version of TFS, it took three years to get that second release. 
And now we're doing that new big release once per year and three updates per year. 
So, like I said, minor miracle. 
Now what is a release? Well you bring together all your code, you integrate it. 
You test it, and you test it, and you test it and test it and test it some more. 
And you're probably going to miss some bugs. 
It's tough to get perfect software. 
So you spend a lot of time worrying that you have missed a bug or you haven't tested enough or it's not high enough quality. 
And part of why you worry is that if it's packaged software, there's not a great way to get fixes out to people very quickly. 
And TFS, for example, well, it's on your servers, which is out of Microsoft's reach. 
Now what does VSTS look like? Who hosts that application? Microsoft hosts that application. Who's the sysadmin? Microsoft is the sysadmin. Who writes the software. Microsoft writes the software. Who applies the patches? Microsoft does. So VSTS, TFS in the cloud, Microsoft controls pretty much everything. Now back to packaged software, with packaged software, it's really impractical to ship often because they have to get it to you. They have to bring it all together, and you have to deploy it onto your servers. But with VSTS, it's not packaged software because nothing's actually getting shipped. Microsoft is doing everything in-house, which lets them deliver new features and new bug fixes every few weeks, which is great. And also what's great is that Microsoft is developing VSTS using VSTS. So when they find a problem, they're going to live the problem. They're going to be very motivated to fix stuff, which really is good for all of us who use VSTS. And this is one of the ways that VSTS is more than just TFS in the cloud. Microsoft ships really often. They ship bug fixes all the time. They use this stuff. They control everything. They do all the deploys and patches automatically on your behalf. And when you think about it, this means that VSTS will always have new features before on-premises TFS. VSTS will always be more than just TFS. This is part of how they test out new features that they will eventually ship in the packaged on-premises version of Team Foundation Server. So if you use VSTS, you're always going to have the latest and greatest, and you don't have to think too hard about it. So, next up: Why use VSTS? 
Why Use Visual Studio Team Services (VSTS)?
Why should we use TFS? Why bother? What's the point? It's not that hard to install TFS. Pretty much if you do the basic installation, it's click, click, click, and you're up and running with Team Foundation Server on one of your servers in your datacenter or on some machine somewhere in maybe like 5 of 10 minutes. It's not that big a deal. So why bother? Well, it's not that hard to install, but there's a lot of ownership overhead. Installation's easy. Owning it, quite a bit harder especially if it's now running your business, if it's at the core of your software development effort. You want to make sure that you don't lose anything. You want to make sure that it's backed up. You want to make sure that it's running so that your developers are productive. So, ownership overhead is where it's at. So with Team Foundation Server, when you install it, it runs on Windows. It's going to need an instance of SQL Server to run. And, honestly, if you've got a team of any size, you're probably going to want two servers, a server for TFS Application Tier and a server for SQL Server. So you'll need a license for Windows, and you'll need a license for Windows for each of those servers, so that costs some money. And then there's the cost of the hardware, which when you really get down to it, I think most people are successful if they have fast and really reliable disks, which means RAID probably. Lots of memory is really important and lots of processor cores. If you want a fast TFS, you need really good disks, lots of memory, and processor cores. No one is going to complain louder and faster than software developers that have to wait for their check-ins to run or have to wait for their get-latest to run. So you want your TFS to run fast. And when you think about that ownership of TFS if it's running in your datacenter, someone's going to have to choose the hardware. Somebody needs to buy the hardware. Someone needs to approve the choosing of hardware and the buying of hardware, and then probably someone needs to hire someone like me to come in and set it up for real, make sure that it's performant, make sure the backups are taken care of, permissions, details, all kinds of stuff. There's a lot of stuff that has to happen in order to make sure that your enterprise grade production TFS is up and running. Easy to install. All that ownership stuff, more expensive, takes actual effort. Then there's all the TFS sysadmin details like Windows patches, SQL Server patches, TFS updates, SSL certificates, disk configuration and performance tuning, backup jobs, build servers, release servers, and VPN access for remote employees. There's a lot of stuff to think about. Not impossible, but it is a lot of stuff. Now let's compare that to VSTS. So in VSTS for a team of five or less, five people or less, create an account, create a project, invite people to your project, it's free, and you're up and running in less than 5 minutes. And you didn't have to go and provision any servers or any crazy stuff like that. You just go create an account, create the project, invite people, and enjoy. And there's a lot less to worry about too once you've done that. There're no servers. There're no patches, no backups. You just use it, migrate your code into VSTS, and let's just say you want to do automated builds, just create a build definition and run it. Build servers are already there for you. It's done. And you don't own those servers. You don't own any of that stuff really. You just focus on your job, which is developing done working software. Developing fantastic done working software. So this is all fantastic. But disclaimer, there are some other details. Nothing's just magically awesome, but VSTS is really easy. We'll talk about these disclaimer-y details later on in the course. So with VSTS, summarizing, a lot less to worry about. Hardware concerns are gone. Sysadmin details are vastly decreased. Your build and release servers are in the cloud. You get new features first. They're going to show up every few weeks. Patches automatically come every few weeks too. You don't have to worry about deploying them. It just works. Microsoft's taken care of that stuff. And that leaves you and your team to focus on your real job, which I'm guessing is probably writing and delivering great done working software. So that's just a quickie intro to that stuff. Let's next up do a quick course overview just to know what we're going to talk about in the rest of the course. 

--------------------------


Getting Started

What have I done? What have we actually achieved with this. 
The Structure of Your Project + Demo of the Azure Portal
We've created a new project in VSTS. So great! 



So when you created that new project, you created a new Team Project that has a whole bunch of 
stuff in it that lets you do a whole lot of things. 
Now you also created a new VSTS account, which is kind of a way, 
if you're thinking multitenancy in cloud computing, this is really a VSTS tenant. 

If you're thinking Team Foundation Server, you've basically created a Team Project Collection, or TPC. 
So in each Team Project Collection, you can have many Team Projects. 
So many Team Projects per account in VSTS. And the account is the container for all of your projects. 
Drilling this concept home, VSTS account versus VSTS project, I think of it a lot like a filing cabinet. 
A filing cabinet, the physical overall structure is the VSTS account. 
And then in that filing cabinet, you've got drawers, and each drawer is a VSTS project. 
The VSTS account is the container for all your individual projects.
 
So, how do you go and view that VSTS account that you created? 
Well, that is going to live inside of the Microsoft Azure portal, and you can get to the portal by going to portal.azure.com. 
Once you get there, you're going to click on Team Services Accounts, and that'll show you your account. 
And that account is going to have subscription information, user types, the actual users, billing and licensing information, build and deployment server information, and information about cloud-based load testing. 
In short, it's the raw details of what's happening with VSTS as it relates to what you're doing. 
So let's do a demo and go take a quick look at that portal and take a look at our account. 
So here's our project. 
We're logged in. 
I'm going to open a new tab, go to portal.azure.com. 
This shows us a whole bunch of stuff, and let's scroll down a little ways. 
We have Team Services accounts right here. 
Click on that. It shows us the accounts that our MSA, our Microsoft account, is attached to. 
And the one we care about right now is this one right here, benday-vsts-2018. 
This is the one we just created. Click on this. And this shows us the information about our account, for example, that it's sitting in the Central US Azure datacenter. 
Here's our URL, https://benday-vsts-2018.visualstudio.com. Our status is active. 
And then we've got a bunch of information about users, build and deployment, and cloud-based load testing. 
Let's click on Users. 
Right now, we haven't purchased anything, and we haven't assigned anything. 
We have five free users that are waiting for us, and we're not using them yet. 
Build and deployment service shows us what our automated build stuff looks like. 
Cloud-based load testing, if you're doing that, click on that, it shows you information about your cloud-based load testing account. 
But let's hop back to Properties. 
So Properties shows us our account name. 
Subscription ID is blank right now. 
We'll talk about why that is the case a little bit later. Our URL and our Azure region. So that's the quick tour of our VSTS account in the Azure portal. 
Now I'm showing you that that exists because it's important to remember if things get nutty, if things get weird, if things stop working in the way that you expect, or if you've got billing questions or all kinds of stuff like that, being able to access your account in the Azure portal is a really good place to start. So remember that it's there. Next up: Let's talk about adding some users to our project and to our account. 


User Types & Security in VSTS + Adding Users Using Microsoft Accounts
We've got our VSTS project. 
We've got our VSTS account, and there's no one using it, so we probably should add some people so that we can actually go and use it to do useful stuff. 
So adding users. 
There are two types of users in VSTS. 
There are Microsoft account users, MSAs, and Azure Active Directory, AAD, users. 
So for those Microsoft account users, it's really the easiest option. 
And you can do everything that you need using MSA accounts, and that's great. 
Because all the account details are handled by Microsoft, it's basically the option with the least amount of friction. 
But it's worth talking about Azure Active Directory users, AAD users. 
These users are organizational accounts, also commonly referred to as Org IDs. 
And you care about Org IDs usually, well, because you're doing enterprise stuff with VSTS. 
So when I say enterprises, I'm thinking about companies or large companies where you're getting your account because it's attached to something that you do for your job. So your account is attached to a company. And what's good about this if you're a sysadmin is that this gives you additional control over what people do in VSTS or anything else. So let's think about some scenarios that you might care about that AAD stuff. For a lot of companies, this shows up because it's part of the company's move to the cloud. 
They've either taken their pre-cloud error Active Directory domain and moved it completely to the cloud, or they're synchronizing it to the cloud. 
So here's a hint. If your company is using Office 365 for email, and you can log in to your workstation at work and then open your corporate email without having to type in a different username and password, this is probably a dead giveaway that your company is already using Azure Active Directory. 
What these Azure Active Directory accounts let you do is it'll let you access all your stuff with one login. 
Now right now, I know for a fact that our VSTS account is not attached to Azure Active Directory. 

But let's say that you're not sure. How can you tell if your account is actually attached to Azure Active Directory? 
Let's do a demo. 
I'm going to show you the security setup for your VSTS account and show you how you can tell if you're attached or not attached to Azure Active Directory. 
So we're in portal.azure.com, and we've gone to our Team Services accounts, and we're looking at our account. 
Now this shows us the essentials, the overview of what's happening. 
There are two things that start to point out that we're not attached to Azure Active Directory. 
The dead giveaway is this thing right here that says Directory, Not connected to a directory. 
There you go. If it says that, you're not connected. Another one that's kind of worth pointing out is Subscription ID right now is blank. 
If you're connected or you could be connected, that Subscription ID is not going to be blank. 
So looking at this, we can see that we are definitely not attached to Azure Active Directory. 
Now assuming that you're using MSA accounts, like we are right now, how do you add a user into your project in Visual Studio Team Services? 
So for this demo, I'm going to show you how to add a user using an MSA account. 
And as that user, we're going to log in, we're going to view the invite, and we're going to connect to our VSTS project. 
So here we are right now. We're looking at MyFirstProject. 
And right now, we only have one member, and that's me. 
Now we could do an add member from right here, click this box, but I'm going to assume that you are not necessarily working from this page right here. 
So let's go to Dashboards. 
So this dashboard right here, this is where you're probably going to land most of the time when you come into your project. 
If you type in the URL, benday-vsts-2018.visualstudio.com, you'll pretty much end up right here. So, we've got Team Members. 
Right now it says, It's lonely in here, Invite a friend. 
So let's type in the MSA of the person that we want to invite. 
We have Demo User. Let's click Add. And that action is successful. 
We added one user to one team. So let's go take a look at what that looks like for our benday-demo1 user. 
So we'll switch over and look at that person's email, and they'll get an email in their inbox that looks kind of like this. So the email they'll get will say, You've been invited to a Visual Studio Team Services project! And it'll have a link to that project. Now this is a different link, different URL than what we're working with right now, but what they do is they click on that link, and that'll take them to a project you just invited them to. What they can also do is they could just pop open a new tab, paste in the URL for your account, so benday-vsts-2018. And that'll take them to a screen that looks like this. It shows them the project that they're attached to, and if you hover over that project, click on it, it takes you into that project. And if you go to Dashboards, now we have two team members, Demo user and my account. So there you go. We've just added a new MSA user into our project in VSTS. Next up: Let's talk about account types, features, and billing.

 
Account Types, Features, and Billing
Now before I dive in to some details on the various types of users, 
I want to remind you that VSTS isn't just for Visual Studio-based developers. 
You don't have to be using Visual Studio. 
You don't have to develop in .NET. 
You don't have to develop C++ for Windows. 
You don't have to focus on any of that stuff. 
It's intended to be cross-platform. 
And, remember, VSTS, just like Team Foundation Server, is not only about version control. 
It's cross-platform. 
Remember that. 
You don't have to be using Visual Studio in order to do it. 
So, let's jump in. 



Next, we have the basic account type. 
 Some missing features, if you're coming from TFS world, this is kind of interesting, and 
I think if you're looking for a comprehensive solution for managing your project, 
this is also interesting. 
So two big missing features that you don't get automatically with basic, you don't get any of the testing, the QA testing features, and you don't get NuGet package management. Now this doesn't mean that you can't use NuGet packages inside your code. You can still do that. What this is saying is you can't use VSTS to host private NuGet packages that only you can see. Now let's say you want to buy those missing features. As of January 6, 2018, when I wrote these slides, if you want to get those missing features, you can add Test Manager into your VSTS account, and that gives you QA testing tools, and that costs $52 per user per month. So now we're starting to get into the place where this is kind of real money. So Package Management, aka private NuGet packages, that is $4 per user per month. Now let's talk about the third account type, Visual Studio subscriber. This is a user who is already paying for Visual Studio. By default, you get the same features as basic users except that this user does not count against your first five free limit. Now if you have enterprise version of Visual Studio, you get a little bit more. You get Test Manager, which gives you the QA testing features, and you get Package Management, which gives you the NuGet package features. Now what if you don't subscribe to Visual Studio but you want to? Well, once again, as of January 6, 2018, you can subscribe. You can get Visual Studio Professional for $45 a month, or you can get it for $539 per year, or you can get Visual Studio Enterprise for $250 a month or just a hair under $3,000 a year. So subscribe to this, have a license of Visual Studio, now you can access VSTS like a basic user, or if you've got Enterprise, you get a lot more stuff. Now, what if you're not a Visual Studio user? Remember, VSTS not only about Visual Studio development. What if you want to buy more of those basic users? January 6, 2018, the first five are free. And if you want more, they're $6 per month per user. So with that, the first five are free. So, one, two, three, four, five users, you're not paying anything. If you have a team of six people, now you're paying $6 a month because you're paying for that 6th VSTS user to access that account. If you have a team of 10, that turns into $30 because the first five are free, the next five cost $6 a month, $30. Now if you want to start adding more users and more features to your account, you're going to have to attach your VSTS account to an Azure subscription. Your Azure subscription is how you pay for this stuff. So in the next clip, I'm going to give you a demo of how to do that. 


Demo: Attach VSTS to an Azure Subscription & Link to Azure Active Directory
Alright, let's do a demo. So in this demo, I'm going to show you how to attach your VSTS account to an Azure subscription. And then I'm going to show you how to hook that up to Azure Active Directory. Here we are in our project. So we're looking at our URL up here for our visualstudio.com account. And let's go to this little gear icon and go down to Account settings. This takes us into a view for our account. And let's go over to the Settings menu for this section. We can see some details about our account here. And if we scroll all the way to the bottom, we've got billing information and Azure Active Directory. So it says, This account is not backed by Azure Active Directory. And then we also have stuff for setting up a billing account. So what we need to do is let's pop open a tab and go to the Azure portal. Portal.azure.com. Left-hand panel. Let's scroll down and find Team Services account. And here we are. We've got benday-vsts-2018. And that says, Not connected to a directory. And we also have an empty Subscription ID. So up here at the top, we've got this button that says Link. This is going to let us link our VSTS to an Azure subscription. Click on this. It shows us the Azure subscriptions that we have access to. So for this one, it's showing me my Visual Studio Ultimate with MSDN. So I'm going to choose that, and I'm going to click Link. So let's say this list is empty, so go to Azure, create a new Azure subscription, and then come back to this, reload, it'll show up. So we'll choose that. Hit Link. It says Linking. And we see a message that says, Success! Finished linking your account to the subscription. So there we go. And now let's go back into our Team Services account and check out what it looks like now that we have that linked. And now that we're in here, we see a lot more information. We see that Subscription ID is populated now. We also see the name of the subscription we're attached to. But Directory still says Not connected to a directory, meaning we are still not connected to Azure Active Directory. So in the next part of the demo, let's go hook that up to Azure Active Directory to populate that field. So getting this linked up to Azure Active Directory now that we've gotten to this point is surprisingly simple. Pretty much all we have to do is click Connect, and then it walks us through the process. So let's go do that right now. We'll click Connect. So this is kind of interesting. So it says that when we connect, only users in that directory will be able to sign in. And that existing user that we added, the MSA user, they're not going to be able to connect to it anymore because, as we saw when we looked at the list of users, they're not in the directory. So they don't exist. So this is one of those things where maybe you don't want to use Azure Active Directory. You have to kind of think about this. Do you want to make your life easy and only use Microsoft accounts? Or do you want that control that you'd have when you're using Azure Active Directory over who is accessing your stuff and have control over it in a way that is tied to your company? I'm going to say, Yes, I want to do this. So I'll click Yes. It says it's connected, and it's telling me to bounce my browser. So I'm going to exit my browser and reopen it. Browser's open again. Let's go to portal.azure. Log back in. Let's go down to Team Services account. Then we'll click the account. And now we are linked to the Subscription ID, and we're linked to the Directory. At this point, there is not a whole lot in this project related to Azure Active Directory, but let's go do something about that. Next up: I'm going to show you how to add Azure Active Directory users to your VSTS project and VSTS account. 
User Management with Azure Active Directory (AAD)
Now I'm going to show you how to use Azure Active Directory users, AAD users, from VSTS. Remember that this is interesting for you if you work inside of a company that is managing Azure resources, managing VSTS using Azure Active Directory rather than Microsoft accounts. And I want to just point out right now that just because you're using Azure Active Directory doesn't mean that you can't use Microsoft accounts as well. More on that in a little bit. So there are two types of users--Microsoft account users and Azure Active Directory users. Actually, it's more like this. There are actually kind of three types of users, so Microsoft account users, Azure Active Directory users, AAD users, and then AAD guest accounts. So if your VSTS account is running only in Microsoft account mode as in it's not linked to Azure Active Directory, then all you care about are MSA users. If it's in Active Directory mode, you now care about Azure Active Directory users and Azure Active Directory guest accounts. I know, it's kind of confusing. So here's a pro tip: So even though you can do some of this user administration stuff directly from the VSTS interface, when you're adding new users into your account, I would say just always go to the Azure portal. Now Microsoft is trying to make this easier to do, but here's my personal opinion, they're not quite there yet. This is a really complex problem under the surface, so it doesn't surprise me that there are issues sometimes. But if you want to avoid the issues, just start at portal.azure.com. Next up: Let's go do a demo of adding some users into a VSTS project that is linked to Azure Active Directory. 
Demo: Add Azure Active Directory (AAD) Users to VSTS
Let's do a demo of this. Assuming that your VSTS is linked to Azure Active Directory, AAD, adding users is a little bit more complicated. And there are a couple of different wrinkles in this. So I'm going to do this as a two-part demo. In part one, I'm going to show you how to add an Azure Active Directory user. So a new user inside your organization. And then in part two of the demo, I'm also going to show you how to add an Azure Active Directory guest user. So this would be including an external user into your Azure Active Directory domain. And typically this would be a user that's using a Microsoft account or maybe is coming from another Azure Active Directory domain. But I'm going to do the demo with that user being a Microsoft account user. And like I said at the end of the previous clip, I think it's probably a really good idea for your sanity to always start doing this by going to the Azure portal first, so portal.azure.com. Start there. You can do some of this stuff straight from the VSTS interface, but more often than not, I have just run into problems and heartache and annoyance. It's getting better, but if you want sanity, if you want to know that it'll definitely work, go to the Azure portal first. So here we are in the Azure portal, and I've navigated to my Team Services accounts. I'm going to double-click on benday-vsts-2018, and we can see it's linked to a Subscription ID and a Directory. Now let's say that we want to add a new user into Azure Active Directory and then use it inside of our VSTS account. For example, this would be you've hired a new employee, and you want to add them in the VSTS. Well, the first thing we have to do is we have to come over to Azure Active Directory, go to Users and groups, and then you can see all the users in your directory by going to All users. So this is the list of all the users that are known to our Azure Active Directory domain. And we have two buttons that are in our menu, New user and New guest user. For adding a user that's going to be inside of our Active Directory domain, someone who works for us, for example, you'd click on New user. A guest user is going to be a reference to a user that exists and is defined external to your Azure Active Directory domain. Let's say an independent contractor who logs in within MSA, a Microsoft account. So for this one, we are going to do a user that works for us, someone that we're going to define inside of our Azure Active Directory domain. This would be like going to your domain controller for your on-premises Active Directory domain and adding a user there. So let's do that right now. We'll click New user. Then we get prompted for the name of this person and then the username. So for the user, this is the human name of the user. We'll do Natasha Nanjiani. And we'll type in her username, which will be natasha.nanjiani, and tab off of that. Now that's going to give us an error because it's saying, Invalid characters or syntax for a username. So let's clear that out. That's saying that our username template has to be the same as the domain. So chris@contoso.com. So this is going to be natasha.nanjiani@bendaylive.onmicrosoft.com. So let's click Create. And that user has been created. And we can see the username right there. Now if you're wondering how did I figure out what that domain name suffix was going to be, well, here's how you do it. Go back to your Azure Active Directory, and then down here we've got Custom domain names. Click this. That shows you the name of your AAD domain. Back to Users and groups. So we've got Natasha is in there. And now let's go back to VSTS and add her into our project. So we're in our project right now, and let's go to Dashboards. And in the upper right, we've got Team Members. So let's click on Manage team members. And now we can search for Natasha. Type in a little bit of her name, and then Natasha Nanjiani shows up as one of the users. Click Add, and now she's part of this project. So let's click on the gear icon, and let's go to Security. Let's look at Members, and Natasha Nanjiani is right in this list. So now Natasha can access this project. So that is adding a user into our project using an Azure Active Directory user. Next in the second part of the demo, I'm going to show you how to do this with a guest account where you can allow a user with a Microsoft account to access your project. 
Demo: Add Microsoft Account (MSA) Users to an AAD-linked VSTS
In part one, we added a new user to our VSTS project using Azure Active Directory, AAD. We went into AAD and created a completely new user and user ID. I tend to think of this approach as being relevant to employees. But not every user is going to be an employee. Sometimes you're going to want or need to partner with people who work at other companies or who are perhaps entirely independent. Now you can just repeat the steps from part one and create a brand-new user account for them, but that's probably overkill. Plus it's super-annoying as that user to have to manage yet another username and password. So you can do the same thing with a guest account. A guest user in AAD is basically a user record in your AAD domain that points at a user that is defined elsewhere, so defined outside of your Azure Active Directory domain. So in part two of this demo, I'm going to show you how to set that up. In this case, we're going to do that with a user who's going to be a guest user who logs in using a Microsoft account, an MSA. So right now we've got benday-demo1@outlook.com in our project. If you try to log in as this person right now, it's not going to work. Now we added this user in a previous demo, but back then we were configured to only use user accounts that were Microsoft accounts, MSAs. Now that we're running with an associated Azure Active Directory domain, this record right here is pretty much useless. And it's useless because our AAD domain doesn't know anything about it. So just to make it clean, I'm going to go remove this right now, remove this person, and then re-add them as a guest user. Let's go back over to Azure Active Directory. And now this time, we're going to add New guest user. So a guest user is someone who's going to be external to our organization. Remember, Azure Active Directory is about managing organizational users. Well, sometimes you want to have MSAs as guests to your Azure Active Directory domain. I know, this gets widely complicated. So let's invite that benday-demo1@outlook.com user, the MSA that we used before. So put in that username, click Invite. And now we have that guest user inside of our domain. So now that we have that person in the domain, let's go back over to VSTS and invite them. So if you wanted to, you could add that user from here, but I'm going to go through that same process again. Go to Dashboards, click Manage team members, and now let's type in that user account. And then we can click Add. And now we've added a guest user into our Azure Active Directory domain and into our VSTS project. So now we have users attached to our account, attached to our project. Next up: Let me show you how to actually assign people user licenses and manage that stuff between the stakeholder, basic, and Visual Studio subscription users. 
Demo: Managing User Licenses and VSTS Extensions
In this demo, we're going to do three things. I'm going to talk to you about assigning licenses to users, so having users in your account that are stakeholder, basic, or Visual Studio users. I'm going to show you how you can add extensions into your VSTS account, and you can buy extensions that add on functionality to your VSTS account, and then assign those extensions to users. So we're here on our project dashboard, and if we want to start doing some permissions management and extension management, user management, go to the gear icon and start there. And let's go to Account settings. And from here, we'll click on the Users menu. And this shows us the users that are in our account. Now since we had enough basic users licenses available to us in our account when we added Demo User 1 and Natasha Nanjiani into our project, they automatically picked up basic. But let's just say that Demo user 1 is an external customer, and instead of using basic, we want to make them a stakeholder. So let's go to Change access level. It shows us their current access level. It's basic. And let's change it to stakeholder. Click Save changes. And now they have a different access level. For my account since I have a Visual Studio Enterprise subscription attached to my live ID, my MSA account, it already knows that I get package management because I have a Visual Studio Enterprise subscription. So let's say we wanted to turn benday-demo1 into our QA user. So right now there're no extensions attached. So let's say Browse extensions. So this here is marketplace.visualstudio.com. So this is where you can get extensions to put into your VSTS account or to your on-premises TFS. And as you can see, there's a lot here. There's a lot that's paid, and there's also a lot that's free. And if we want that person to have access to the QA features, let's come over to the most popular, scroll over a little bit, and then we get Test Manager. Let's click on it. And then let's get this. So we'll click Get. And it asks us which Team Services account we want to add this to. So I'm going to choose benday-vsts-2018. Choose our subscription. Click Buy. So now it's asking us, How many licenses do we want to get of this per month? And one of the things that we're going to notice over here on the right is that it says Extension cannot be assigned to stakeholders. So there goes our great idea of turning a cheap, free stakeholder license into a QA person. Not going to happen because he can't use this with that license type. So we're going to have to go back and change that person to basic before we can make them a QA user and assign this Test Manager license. But let's come in here, and let's say 2. So we'll buy two licenses of this and hit Continue. Confirm our order. And now back to Manage users. So now we have Test Manager as one of the extensions. And if we open that up, we see we have two available licenses, and they are not assigned to anybody. So let's come over here to our stakeholder, benday-demo1. Let's change their access level, change it to basic because you can't assign the Test Manager to a stakeholder. Change it to basic. Now let's come back over here to that user and say Manage extensions. Under Extensions, check Test Manager and click Save Changes. And now we've assigned one of those licenses to that person. If we want to assign Test Manager to Natasha Nanjiani, we can do the same thing. Right-click, Manage extensions, choose that, and then Save changes. While we're in here, let's take a look at Projects. We can also see what projects this user is in. So since we only have one project in our account, MyFirstProject, we see that that person is part of that, and we can change which group they're attached to. So if we wanted to do this, we could click Save changes. But I'm not going to do that right now, so I'm going to hit Cancel. So there you go. By coming into this view, you can change what type of user they are and what extensions they get to have access to. Next up: Let me show you about how to do basic permissions management. 

Permissions Overview
Let's talk about permissions. 
So thinking about security, user access into our project. 
If you're sane, if you like life to be nice, if you like happiness, just manage your VSTS permissions using the existing groups and using group membership. Keep it simple. So VSTS groups, there are a number that come just by default. They're automatically created for you. These groups are relevant at the account level, project level, or team level. So for VSTS account level groups, there's only one you really care about--project collection administrators. If someone's in this, they can do all operations on all projects in your account. They can also create new projects. So if you want to create a new project, it helps to be a project collection administrator. Here's a pro tip: Have more than one member of your project collection administrator's group. If you only have one and then for some reason they get kicked out of your account, guess what? You're kind of stuck. So have more than one so you have a backup. So if one person gets knocked out their account for some reason, you've got somebody there who can fix the permissions and let the other people back in. Groups that you might care about at the project level, project administrators. So a project administrator can do all operations on that project. Then you have project contributors. They can add, modify, delete pretty much anything inside the project. And then you have readers. Readers have read-only access to the stuff inside that project. There are also team level groups and team level permissions. So, by the way, you can create teams inside of your project. And teams are a way to subdivide what happens inside your project. So your project might be gigantic. Let's say 50 people work on your project. It might start to get a little bit unwieldy if you have 50 people that are all just sitting right in contributors on that project. You might want to subdivide stuff, subdivide them into teams. And then what you can do is you can manage permissions for members of the team, and they don't have to have the same permissions on every single team. You can mix them up, change them around. So permissions at the team level can be kind of helpful. So here's another tip: Don't go locking everything down unless you really need to because you'll start pulling your hair out at a certain point. So for those permissions, if you just keep it so that they're either members of a group or not members of a group, that gets back to the, If you like sanity, happiness, etc., then managing permissions for team-level groups, it's pretty close to being the same as adding somebody into a project contributor group. So they either can access the stuff as a team or they can't. Don't try to subdivide and customize that stuff. Just keep it easy. Leave it to group membership. Now that said, you don't have to. But if you like sanity, happiness, etc., do yourself a favor and keep it simple. Next up: Let's do a demo of this stuff, so a permissions demo with VSTS. 

Demo: Permissions Management
So let me give you a quick tour of permissions management inside of your project. So here we are in the dashboard for MyFirstProject. And let's go look at our permissions on our account. So go to the gear, go to Account settings. This brings us to the information about our account. So, remember, the account can contain multiple projects. Let's go to Security. And here are the groups that exist at the account level. Like I said, I think you really probably only care about project collection administrators. So let's click on that. This user can do any operation inside the account. Let's go to Members. Service accounts are in this. Service accounts are basically services that do stuff on your behalf behind the scenes. You don't really have to worry about that. So right now my account, benday@live.com, is a member of the project collection administrators. So like I said, you probably want to have more than one of these. So if you want to have another project collection administrator, click on Add, search for a user you want to add into the project collection administrators, for example, Natasha Nanjiani, and click Save changes. That'll add them into this group. So since I'm a member of project collection administrators, this means that, well, I can create projects. So let's go back to Overview for a second. And just to make this interesting, let's create a new project. Right now we only have one. Let's click New team project. And let's give it a project name, Project 2. Choose Git for right now. Start it off using Scrum because I'm a Scrum guy. And then click Create. So now we have Project 2. Let's go back to Account settings. Now for the overview for account settings, we now have two projects-- MyFirstProject and Project 2. So let's go look at permissions on my project. So there're a couple of ways that we can add permissions for our users. So let's go in right now into the Users section. It shows us the users that are known to our VSTS account, and let's go look at Demo User 1. So right-click on this, we can see Manage projects. Manage projects shows us which projects this user works in. So their access level is attached to the account, but then they can be members or not members of the various projects. So right now this person is not a member of Project 2. So if I choose Project 2, check that off, I get the drop-down menu that shows us what groups this person is in. So by default, it puts them in the contributors. But let's say that we want to have this person be a contributor for MyFirstProject and a reader, so have read-only access, to Project 2. Well, you'd choose it like this and click Save changes. Or we could make this person a project administrator for Project 2, click Save changes, and now that changes their permissions. So there's another way that you can manage their permissions. Let's go back to Overview. Let's go look at Project 2. So on Project 2, we're now in the context of Project 2 administration. Let's click on Security. And here we are. We've got the groups that are attached to the project level. So project administrators, project contributors, project readers. So let's go look at members. Right now, my account, benday@live, is a member of this group because I'm a collection administrator. And then from that last screen, I added benday-demo1@outlook.com in as a member of project administrators. So I also could do a similar thing, let's search for Natasha. I could put Natasha in this group too. Save changes. Hit refresh. And now Natasha Nanjiani is a project administrator. If I want to remove her from this group, click Remove. And, well, now she's out of that. If we want to add her into contributors, we click on Contributors, click on Members, click Add, search for her name, click Save changes. And now she's a member of contributors for this project. We also have teams. Right now we just have a default team, Project 2 Team. But let's say we want to create a new team. Click on Overview. And on Overview, we have this button right here. It says New team. So let's create a couple of new teams. Team A, Team B. And now if we click on one of these teams, we get team members. And right now it's just me because you're inheriting my permissions as a collection administrator. But we can add other users into this team, and that's how we administer permissions on teams. Notice up here at the top that it says Project 2/Team B. This lets us change the context that we're working in. So if we go to Browse, browse will show us a whole bunch of stuff. If we click on the gear, go to Overview, it takes us back into our VSTS account overview, and we can see MyFirstProject and Project 2. So two ways to administer security. One is from the account. You go into Users, right-click, and then say Manage projects. This gives you a simplified way to add them into projects or remove them from projects. You also can go to Overview, go into one of your projects like Project 2. You can either add permissions for the team, or you can do Security at the project level. Go to Members and add them in to either a team group or one of the project level groups like contributors or readers. So there you go. There's our quick tour of permissions management for users inside of your account and for your projects. 

Summary
In this module, we talked about how to get started with VSTS. 
You created a new project, created a new VSTS account. 
I showed you a couple of different ways to add users to your project.
We talked about account types. 
We talked about billing, licensing, and extensions, and how to assign those to various users. 
We talked a bit about Azure Active Directory integration, AAD, 
how to tie that in to your VSTS account (como vincular eso  a tu cuenta de VSTS) if you're using AAD. 
okAnd then, finally, we wrapped up talking about user permissions management, 
how to add users and change their permissions. 
Basically control what they can do and what they can see inside of your team project. 

Next up: Let's start talking about how you're going to manage your code. 
Let's talk about source control. 



Managing Your Source Code with VSTS

Overview
Hey everybody! How's it going? This is the Managing Your Source Code with VSTS module. 
Quick overview of what we're going to talk about. 
We'll start off with a level set, just why do we even care about version control? 
Just to think about why we might use it. 

Then we'll go in to the two different types of version control that are available in VSTS, 
which brings us to discussions of distributed version control versus centralized version control. 

We'll cover the basics of Team Foundation Server version control, the basics of Git, basics of branching with Git, 
and then how to do code reviews with Git using pull requests. 
Why Version Control + Version Control Options in VSTS
So let's dive in on our version control stuff in VSTS. First off, why version control? Well, whether you work by yourself, work with a team, or work with multiple teams, you're going to care about version control because it's the integration point for everything you do. Even if you work by yourself, it still is nice to have just one place that you put your code in and it's controlled so that it protects you from making mistakes because we still make mistakes even if we work by ourselves. If we work with other people, well, that just becomes more important because we're constantly bringing our code together, and there, well, there are going to be problems sometimes. So version control gives you tools for integrating your stuff, bringing all your code together. It gives you features for tracking and comparing history. There are two types of version control systems that are available to you in VSTS--Team Foundation Version Control, TFVC, and Git. Let's compare the two. TFVC was created by Microsoft. It's been available in the product, and it's been available in TFS since the very beginning, all the way back starting with TFS 2005. Git was created by Linus Torvalds. The initial release was back in April 2005. And support for Git was added to TFS and VSTS in 2013. Now the really big differences between these two are how they think about version control. TFVC is called centralized version control, and Git is known as distributed. So let's discuss the difference between centralized version control and distributed version control. Centralized generally needs a network connection in order for you to do most operations. So add, edit, delete, check in, check out, branch, merge, pretty much anything you do, you really have to have a network connection. With distributed version control, you pretty much don't need a network connection until, well, ever. Basically, you don't need it until you need to share stuff with somebody else. So add, edit, delete, check in, branch, merge, undo, everything's available offline. Now TFS local workspaces, TFVC local workspaces give you the ability to do one level of undo. So if you want to undo check out, you can do that disconnected, and you don't have to talk to the central VSTS service. But that's not a lot. Let's think about Git or distributed version control. You want to revert to something that was checked in two years ago? Fine. Perfectly happy to do that because it's got a complete copy of everything offline on your local machine. Centralized version control, this is a really big difference. The central server knows what version is on your machine. It knows what you have, and that's how it can do a lot of its magic. But since the central server is what is governing what has to go on your machine and what the differences are, well, that's why you almost always have to talk to the central server. Now on Git or distributed version control systems, the remote server doesn't really know what you have until you push your changes. So you end up batching all the adds, edits, deletes that you do locally, and you can do that completely offline, and then you do something called a push, which takes all your pending changes that you have locally, pushes them up to the central server. So like I said, it mostly doesn't need a network connection until you want to share your changes with somebody else. And that brings you to the question of, Should I use TFVC or Git? And that's what we're going to cover in the next clip. So next up: Should you use TFVC or Git? 
Git vs. TFVC
So you know now that you have two different options for version control in VSTS. 
You can either use TFVC or Git. 

Now, big question, Which one should you actually use? 
Well, there really isn't a clear answer. Pros and cons of TFVC. One of the big pros of TFVC, especially if you've been using centralized 
version control for a long time, is that it's familiar. It's the way that we've worked for a really long time. 
Your changes are really easily tracked because you're talking to the server pretty frequently. 
TFVC gives you really granular control over your security, so if you need to lock down your security in really creative ways and really specific ways, well, TFVC might be for you. TFVC is very happy with extremely large repositories, a lot of code, a lot of binaries, a lot of stuff. If your repository is big, it's really happy to do that. And the tooling is really mature because it's been around for a long time. TFVC, it's been going since TFS 2005. So it's been battle tested. The biggest downside on TFVC, and this is going to sound kind of weird, it's just not what the people are using anymore. It's not what the cool kids want to use. It's kind of the Friendster or MySpace of the version control world. Another con, offline support is weak. Now just skipping ahead for a half a second to Git, once you get used to Git's offline support, it's really hard to go back to TFVC. If you care about doing code reviews and using TFVC, well, let's just say that the code review flow in TFVC is kind of underwhelming. That's a euphemism for not good. If you want to do code reviews, then you might find TFVC's code review flow is kind of annoying. Another thing that's annoying is folder-based branching. That's the way that TFVC handles it, and it's just difficult. And it's confusing. Git handles branching in a different way that's a lot easier to use. Let's do the pros and cons of Git. One, it's shiny and new. People really like to use it. This is the hot thing. It's in-style, and it's popular. The offline support, the disconnected support, you don't have a network connection, offline support is amazing. It's really great. I think this is a giant, giant pro in favor of Git. If you want to do branching, it's a lot easier to understand, and it's a lot easier to do than branching is with TFVC. Now code reviews in Git are related to branches. They're called pull requests, and the support for pull request-based code reviews is really good. Like I said, code reviews in TFVC, they're not really very usable I think. There's tons of enthusiasm in the Git community. There're lots of people that use it. It's cross-platform too. So if you know Git from using GitHub or any of the other zillion vendors that provide Git, well, you already know how to do it in TFVC. So that's fantastic. Cross-platform, lots of community enthusiasm. On the con side, there's a pretty good learning curve. If you're used to doing centralized version control, well, there's a good chance you might get confused and lose changes. This only gets worse when you have teams of people that are working together that are not really used to using Git. They'll learn, but in the beginning, it might be a little bit painful. Security is at the repository level. Generally speaking, you either have access to the repository, which gives you full access to do pretty much everything, or you don't. So it's Boolean on or off. That's different from TFVC. TFVC, there're lots of ways that you can lock down permissions for what people can do. If your source control repository is huge, it can be a little bit challenging and a little bit disk intensive. Now Microsoft is actively working on this. There are some things that they're doing that are already out that help to deal with that huge repository problem so that this is becoming less of an issue every single day. But for right now, you do kind of have to think about it. As a way of talking about how bought in Microsoft is on Git, the Windows team is now using Git to develop Windows, which makes it the largest Git repository in the world. And Microsoft is contributing back to Git as well, so they're actively working on this. So Git or TFVC? I don't think there's a right or a wrong answer. But if you're starting fresh, and you don't have a strong opinion, I would say just start with Git. And as a disclaimer, this course is mostly going to focus on Git. I'm going to do some stuff with TFVC, but after we cover the TFVC content, it's going to be Git from here on out. Part of the reason why is that TFVC has been stable for years, and it really hasn't changed much since TFS 2012. And I've already covered this content in other Pluralsight courses. So if you want a really deep dive comprehensive tour of TFVC-based version control, check out my ALM with TFS 2012 Fundamentals course. It's kind of old, but it really hasn't changed. So go check out that course, and go to the Version Control Basics and Version Control Beyond the Basics modules, and that'll get you that deep dive into TFVC. That said, next up: I'm going to give you a quick overview of TFVC. 
TFVC Demo, 

Part 1: Create a Project and Connect with Visual Studio
Let's do a demo. More precisely, let's do a series of demos because, well, if I show you this in one demo, it's going to be 25 minutes long. So we're going to break it up into a bunch of different pieces. So we're going to start fresh, and we're going to create a new project in VSTS, and we do that when we go through the wizard for creating a project. It's going to ask us what kind of version control provider we want to use. In this case, we're going to choose TFVC, Team Foundation Version Control. From there, we're going to connect Visual Studio up to this new project, and then we'll set up the version control repository for our project. And this is going to be just basically creating a Main folder. I'll talk a little bit more about why we do it that way in a bit. From there, we'll add a new project in Visual Studio through Solution Explorer. We'll check in our code. Then we'll do some modifications to the code, check in our code with an associated bug, an associated defect in the work item tracking system. I'll give you a tour of the version control web interface in VSTS. And then, finally, a little bit about how to get the latest changes off the server and on to your local developer workstation. Now I want to remind you that this is not meant to be the comprehensive tour of TFVC. For that, go check out my ALM with TFS 2012 Fundamentals class. The URL's right there on the bottom. It's in Pluralsight. Check out Version Control Basics and Version Control Beyond the Basics. I know you might be thinking, 2012, that's kind of old. Well, this stuff has not changed very much, so you can watch that, get the deep dive on TFVC. So I've opened up a browser, and I have gone to the URL for my VSTS project. So in this case, it's benday-vsts-2018.visualstudio.com. Now what I want to do next is I want to create a brand-new project. We've got some existing projects that are there, but let's start fresh. So we're going to come over here and click the New Project button. It asks for a project name, a description, version control provider, and what work item process we're going to start from. So I'm going to give it a name. I'll call it demo-vsts. Give it a description, Project for VSTS basics demo. Version control repository, I'm going to choose Team Foundation Version Control. And then work item process, for this I'm going to choose Scrum. We'll talk more about this process template stuff later on in the course, but for right now, choosing one of these values just sets up what the default project management templates look like inside your project. And because I'm a Scrum guy, I do a lot of Scrum coaching and a lot of Scrum training, I'm going to choose Scrum. We're ready to go. Let's click the Create button. And here we are on a landing page for our new project. So we have this landing page. And at this point, we're not connected to Visual Studio, but we really want to be connected to Visual Studio. So I'm going to open up Visual Studio right now. Here's Visual Studio. This is Visual Studio 2017. So the first thing I'm going to do is I want to connect Team Explorer to my project. So Team Explorer is this window right here. It's our interface to TFS or VSTS. If it's not visible to you right now for some reason, you can open it up by going to View and choosing Team Explorer from this menu. So we have Team Explorer here, and there's a little plug icon. This is the button that brings up Manage Connections. Now I've got a handful of connections that are already here. But the thing you want to do is click Manage Connections on the Connect dialog and say Connect to a Project. Now there's a possibility that you're logged in as more than one person on your computer and in Visual Studio. And I am. I'm logged in as my organizational count and also as benday@live.com. I'm going to switch over and choose my Microsoft account. And I'm switching into the Microsoft account because that is the user I was logged in as when I created that project. So as you can see, it shows me a list of Visual Studio instances, VSTS instances that I'm connected to. And the one I care about is benday-vsts-2018. So open that up. And we've got demo-vsts inside that. So click on it. So this is the project we want to connect to. And when I click on that, you see that the Connect button lights up at the bottom. So we'll click Connect. And now our Team Explorer window is lit up with information related to that project. It's connected now into Visual Studio. In the next part of the demo, I'm going to start setting up some of the version control stuff. 
TFVC Demo, 

Part 2: Create a Workspace Mapping and Initialize the Repository
Now one of the things it's asking us right now is to configure our workspace. So our workspace is our connection between version control on our local machine and version control on VSTS. So this is trying to map us in to demo-vsts version control repository, and it's saying it's going to put it into this path right here. I'm going to change that just a little bit. And I'm going to put it into C:\code\demo-vsts. There's nothing magical about that location. It's just easier for me to remember, and it puts it with the rest of the code on my disk. So from there, I'm going to click Map & Get. So the Map & Get button creates a relationship between a local machine and VSTS and brings down any source code that is in that repository. It was mapped successfully. And, well, there's no code in here, but let's go look at Source Control Explorer. Source Control Explorer is our view directly into source control in VSTS when you're using TFVC. Click on that, and it shows us our pretty much empty version control repository. So what I want to do next is I want to create a folder that is going to contain the code that we're going to work on. Now you might be thinking, Why aren't we just putting the code directly into this folder right here? Well, you could, but it'll cause problems later on, not to mention the fact that it's kind of messy. So what I do is I always create a folder called Main, and that's where I put my code. So I'm going to right-click inside of Source Control Explorer, and I'm going to say New Folder. I'm going to rename the folder to Main. And now we have that folder. If we click on this link right here, this'll open up explorer.exe, file system explorer. So if we're looking at file explorer for that directory, we now have our Main folder. We also have in this column that says Pending change, it says add, meaning that we've added something. We have a pending change, which is an add of a folder. So let's check that in to the server. So right-click on it, and we'll say Check In Pending Changes. This brings up the Pending Changes window. And let's provide a comment. We'll say Created Main folder. Click Check In. And now we've checked in that add of a folder. We've got the basic structure of the workspace set up, and now we're ready to start adding some code. And that's what we're going to do in the next demo. Next up: Adding code to TFVC. 
TFVC Demo, Part 

3: Add Code and Check-in Pending Changes
So next up, let's go and create a new project. So we'll add some code into this. A really easy way to make sure we put it in the right place is to click on Home. That takes us to the Team Explorer - Home page for our team project. And down here at the bottom, we have this thing that says Solutions. And if we click on New, that'll get us going for creating our code and putting it in the right place on disk to make sure it shows up in the workspace. So we'll click on New. It automatically populates our location with the right stuff or pretty close to the right stuff. So I'm going to change that to say \Main so it goes in the Main folder. And let's create a console app called HelloWorld. Hit OK. We've got the basics of that right there. And if we look at Source Control Explorer, we can go into the Main folder. And now we've got a new folder called HelloWorld and a bunch of code that's sitting inside there. So let's go ahead and check in this code. We haven't done anything with it yet. We just have the empty shell of a program, but let's check it in. So we can do that by going to Solution Explorer, right-click our solution, and then we'll say Check In. We'll give it a comment for the check in, and we'll say Added basic Hello World structure. So before I hit the Check In button, I want you to take a look and pay attention to what happens to the things in this Pending Change column. Right now they're all adds. So let's click Check In. Now you can see that all those things that were in Pending Change, add, have gone to no pending change. So let's go and do a little implementation. Let's go over to Program.cs, and we'll do Console.WriteLine("Hello, World."). And as you can see, as we make the modifications, our Pending Changes window picks up our pending changes. So in this case, we see we have a modification for Program.cs, which is what we just did over here. Give it a comment, we'll just say Implemented Hello World, and check that in. So we've made a bunch of changes and checked a bunch of stuff in, basically checked it in, pushed our changes up to VSTS. Now what if we want to go look at that stuff? A great way to do that is through the web interface. And I'll show you how to do that in the next part of the demo. 
TFVC Demo, 

Part 4: TFVC Through the Web Interface
So far, we haven't taken a look at what VSTS knows about the stuff we're doing in version control, but we can do that through the web interface, so let's go check that out. So let's pop open a browser and go check out what's happening on VSTS. So let's click on the Code link. And this looks an awful lot like Source Control Explorer in Visual Studio. If we click on History, we can see the history of the changes we did and what we checked in to version control. So if we go over here and click on this change set for Implemented Hello World, we can see that we changed one file, and that was the change we made. So this web interface here gives you a basic view into source control. You can do some basic modifications of stuff if you want to like, for example, let's look at App.config, we can do an edit if we want to. So let's click on the Edit button. We're now editing this. And let's just add an XML comment. Click Check in. We just saved our changes. So you can do very basic edits through the web interface, which is kind of handy. So that is the web interface, basic, quick demo of that. Next up: In the next demo, I'm going to show you how to associate things from your project management structures to things you do in version control. So we'll associate a bug to a check-in in version control. So let's go and pretend that we have a defect. 
TFVC Demo, 

Part 5: Associate a Bug to a Check-in
So let's hover over Work, bring up the Work menu, and then let's choose Bug. And let's give it a title. Let's say it should say Hello World! with an exclamation point. So we'll put that in. We'll save it. And right here, we have the number for this bug. It's called the work item ID, and this is the first one we've ever created in this project, so the value is 1. This is not a super-descriptive bug, but I wanted to put it in there so we can actually use it. And let's assign it to me. So let's go to this Assigned, set it to me, and then I'm going to hit Save and Close. Now let's actually do something with this bug. Let's go down to Visual Studio. So here we are in Visual Studio. And since we made that change through the web-based code editor, if we go to Solution Explorer and double-click on App.config, it does not have that comment there. So one of the things that you should be doing periodically is Get Latest. So right-click on your solution, and choose Get Latest Version from the menu. That pulls down the latest version from the server. So now let's go work on that bug that we've got. So we'll come over here, and we'll change this to say Hello, World! with an exclamation point, save it, and now let's go and check this in. So Check In. And right here, we've got Related Work Items. So there're various ways you can access work items. I happen to know what the number is, so I'm just going to type it in by number. So it was work item 1. Click Add. And now when we check in this change, it's going to check it in and associate it to that bug. So let's say Fixed typo. Let's hit Check In. Checks in that change. And one of the things we've got here we can look at is Changeset 9. If we click on that, that'll show us the details of what we just checked in. So it shows us the comment. It shows us the related work item. And it shows us the file that we changed. And if we right-click on that file, we can say Compare with Previous Version. And that'll show us the difference between what it was and what it is now. Back here in the web interface, let's go to History. We see Fixed typo. We see what was going on. We see it's associated to one work item, so let's click on that. We can bring up the actual work item. And when we bring up the work item, we see it's associated to Changeset 9. So as you can see, you start getting some traceability there. Let's say that we're happy with this, and we want to close this bug. Let's change it to Done. Hit Save and Close. So there you go. That's our quick tour of Team Foundation Server Version Control. Next up: We're going to cover the basics of using Git. 
Git + VSTS
Let's talk about the basics of using Git with VSTS. Now this is going to be a fairly fast tour of this. If you're looking for a more comprehensive tour of Git, check out my DevOps Skills for Developers with Visual Studio and TFS 2017 class and go straight for the Consolidating Your Team's Source Code with Version Control module. You might also be interested in some of the branching stuff that I talk about in the Feature Flags: Simplify Branching and Deployments module. So if you're looking for something deeper dive on Git, go ahead and check this out. On with the basic tour. A really big important thing to make note of is what is local versus what is remote. Local is what you have changed on your local machine, and remote is what is up on the server. So let's talk about the basic flow of working with Git. So the first thing you're going to do is you're going to clone the remote repository. You're going to do this one time, one time only, and this creates a local copy of everything that's in the version control repository onto your local machine. That's not just the current version. That is every single thing that has ever happened in that repository since the beginning of time. From there, you're going to work locally. You'll do your adds, edits, deletes, whatever you have to do, and when you check in to your local machine, you're going to do something called a commit. A commit is what you call a local check-in. You can keep going back and forth, add, edit, delete, commit, as much as you want. So repeat that a whole bunch of times or one cycle, it doesn't really matter. You can work locally, and you can work disconnected from a central server indefinitely. At some point, you're going to want to share the stuff you're doing. And if you share, that's called doing a push. So you're going to take all of your local commits, all the changes you made locally that are only available on your machine, and push them to the remote server. In the case of VSTS, the remote server is going to be VSTS. So that takes all your local commits, pushes them up to VSTS. That's the basic flow. 
Git Demo, Part 1: Create a Project + Initialize the Git Repository
Now let's do a demo. So in this demo, we're going to start from a clean project in VSTS once again. We're going to create a project, and we're going to say we want Git as our version control provider. We'll connect Visual Studio to the project, do initial setups of the Git repository, add some code, do some local changes, some local commits, push those changes up to VSTS. I'll give you a tour of the web interface for version control. We'll make some changes via the web, and then we'll do a Git Get Latest, which is basically a fetch and a pull or a sync. So basically how do we bring stuff down that has changed on the server. And then, finally, we'll wrap up this demo by doing some commits that have associated work items, so associated work items where we're associating a bug or some other kind of project management thing to the commits that we're doing into Git. So on with the demo. So here we are in the web interface for our VSTS account. It shows our list of projects right now, and I want to create a brand-new project just so we're starting fresh. So we're going to click the New Project button. And it asks us for a name, a description, version control provider, and work item template process. I'm going to call this git-demo. This is the project for the Git demo. I'm going to keep Git as my version control provider, but as you remember, there's actually Team Foundation Version Control as well. Leave it as Git. And because I'm a Scrum guy, I'm going to set my project to start assuming that I'm using Scrum. So this is the beginning of what we want. This is our Create new project dialog. And at this point, we can click the Create button. The project has been created. It dumps us right into this view right here. This is pretty much what we would see if we clicked on Code at this point. So our Git repository's empty, nothing in it. Our Git repository has a URL, and here is that URL right there. You don't have to have it memorized, but it's good to know that that is how you address your Git repository. Now the first thing that I would probably do is I want to set up the types of files that Git cares about. At the moment, anything that you put in a Git directory, it's going to say, This is something I care about. Now assuming we're doing Visual Studio development, there's a whole bunch of stuff that we don't care about like anything that's under bin or anything that's under obj. So there's this file in Git called gitignore, and this just says, What do we ignore or not ignore? So I'm going to click on initialize with a README or gitignore. I'll just say Add a README, Yes. It'll just add an empty README for my repository. Then it says Add a .gitignore, and I'm going to type in VisualStudio. Actually, before I do that, there're a whole lot of other gitignore templates that are available to you. So if you're not doing Visual Studio development, you can start someplace else. But I'm going to assume Visual Studio. So I'll choose VisualStudio from that list and click Initialize. We've initialized the repository and all the helpful information has now gone away. So where's it gone? Well, we're going to go over to Code. So click on Code. And now we see our Git repository. So this web interface is the web interface into our source control repo. We have a gitignore and a README.md. Those are the things we just initialized this with. If we click on History, you see that we have one commit, and it's that right there. Now we want to connect Visual Studio into this. And that's what I'm going to show you how to do in the next part of this demo. In this next part of the demo here, 
Git Demo, Part 2: Connect Visual Studio to a Git Repository in VSTS
I'm going to show you how to connect Visual Studio into this Git repository that lives in VSTS. So there are a handful of ways we can do it. The easiest way, at least through the web interface, is to come over here, click on Clone. And if we want to do it from the command line, we can. We can just grab this URL for our repository right here and then do Git command line stuff. I'm going to assume that we're going to start by cloning using Visual Studio. So I'm just going to click on this button right here. If you pull this, you also have the option to clone using other products. So as you can tell, VSTS supports a lot of different stuff. But I'm going to clone in Visual Studio. So I'm going to click this button right here. And up comes Visual Studio, and it pops open this dialog right here saying, Where do you want to clone this to? It populates it automatically with where it's coming from. Where do you want to clone it to? So, I'm going to put this in code\git-demo. That just happens to be where I put it on my disk. This can be anywhere you want on your disk. Then I'm going to click the Clone button. So that's cloned. So, what I'm going to do right now is I want to create a brand-new project, and I'm going to put it into this directory right here, C:\code\git-demo. So I'll go to File, New, Project. Change the location to be the location of my Git repository. And I'm going to say HelloWorld. And that should be all I need to do. Go ahead and hit OK. And there's our new solution. We've got these plus symbols that are next to everything. That indicates that these are adds. So let's say that we want to check in our changes. That's called in Git doing a commit. What I want to be able to do is right-click on the solution and go to Check In Pending Changes or Commit, but there's something weird about how Visual Studio 2017 works that it gets a little bit confused when you're using a brand-new project. So if you go to that menu, and you don't see Commit there, well, you can always go to Team Explorer. So click on Team Explorer, and then you can go to Changes. So on Changes, scroll down a little bit, we can see all the things that it wants to add into our Git repository. So Let's give it a message. We'll say Created basic structure of hello world. And we'll say Commit All, and that's committed that. So it gives us a link saying that it created this commit locally, and we can do a sync to share our changes with the server. Now remember that I said that you have to pay attention to what's local versus what's remote. So let's go up to the web interface for just a second. So we're in Code for our Git repo. Let's just refresh it. And if we look at it, we don't see any of those changes we just did when we created the Hello World project locally. That says to us, and this is one of the things that can be a little confusing with Git is that you think that you've committed your changes, but the difference is that you've only committed locally, you haven't shared it with the remote. You haven't done a push. So let's go back to Visual Studio. And let's click on Sync. This takes us to the Synchronization section of Team Explorer. We can also get to this if we're on Home in Team Explorer, so you click on the Home button. We've got Sync. This will show us our incoming commits, so commits that are coming from the server, and outgoing commits, things that are going to the server. So we've got one. This is the stuff we just created locally. Click Push. And that says that we successfully pushed. So let's go back to the web interface and refresh it. Now we see HelloWorld. And if we look at History, we see the commit for Created basic structure of hello world. So we've pushed our changes up to the remote. And in the next part of the demo, I'm going to show you some of the things you can do in the web interface. 
Git Demo, Part 3: Git from the VSTS Web Interface + Staying Up-to-date in Visual Studio
In this next part of the demo, I'm going to show you two things. One, how to edit files in Git using the VSTS web interface and, two, how to do a Get Latest with Visual Studio and Git. So basically what we're going to do here is we're going to make some changes on the server and then pull those changes down to your developer workstation using Git and Visual Studio. So you can edit files directly through this interface. So let's come in and do a quick edit. So let's go to App.config. We'll click the Edit button. This puts this in edit mode, and then let's just add a comment. So we add a comment to App.config. We'll say Commit. That commits directly to the server, directly to our remote. So at this point, that means that our developer workstation is a little bit out of sync with what is up on the server. So let's go back to Visual Studio. And we're on the Synchronization section of Team Explorer, and let's say that we want to do a check to see what we should bring down from the server. So what we can do is we can do a fetch. It shows us we've got one change right here. And then if we're good bringing that change down, we can click Pull. So fetch gets the list of incoming commits, and pull actually brings them down. So now if we look at App.config, we're in sync with the server. So that's basically us doing a Get Latest in Git. In the final part of this multi-part Git demo, I'm going to show you how to associate a VSTS work item, a VSTS work item is typically a piece of project management or bug tracking, and show you how to associate that to a Git commit. So that's the next demo. 
Git Demo, Part 4: Associate a Bug to a Git Commit
Let's do one more bit of this demo. Let's say that we get a bug, so let's go ahead and create a work item, which is a bug. We'll give it a title. And let's say Hello World doesn't say "Hello World." Let's choose who this is assigned to. We'll assign it to me. And I'm going to click Save. And when we save it, it populates what's known as the work item ID, and that is 2 for this one. So this is bug #2. Remember that number. So we'll close this out. Let's go down to Visual Studio, and let's say that we know that that bug exists, and it's been assigned to us, so let's go fix that bug. So we come into Main, and we see, yup, alright, we don't do Hello World. So let's implement that. We made our change locally. Let's right-click on our solution. And now you see we have Commit showing up. So we'll choose Commit. It takes us right to Changes. And we've got this section on the Changes dialog that says Related Work Items. There's a button in the corner of this section. It's a little bit hidden. It's a little bit small. And it's the Add Work Item by ID button. So we'll click on that. I happen to know that it is work item #2. So I'm going to say Add work item #2 to this. And now let's give it a message. We'll say Fixed this bug. Now what we could do is we could do a Commit All. Commit All will just commit it locally. If you're feeling really adventuresome, you could say Commit all and Push, which will commit it to the local and then push the change directly to VSTS. Or if you're feeling wildly crazy, just hair-on-fire, yay, the world is mine, you can do Commit All and Sync, which will push your change and then also do a Get Latest against the remote. Because I know that there is no penalty for doing this, I'm going to do Commit All and Sync. So that syncs me entirely and pushes that change up to VSTS. Now let's go up and take a look at that bug. So we'll go to Work. We've got the bug right here. Open it up. And since we associated that bug to our commit, now we have this associated commit right here. So it automatically links the bug to the change that we made in version control. So if we click on that link, it takes us into the details for that commit, shows us what changed in the commit. It also shows us we have a link back to the work item. So if we click on this, it'll take us back to where we were, which is our bug. And since we fixed it, we can go to state, pull the drop-down, and mark it as Done, and then click Save. So there you are. There's our quick demo of Git, the basics of doing Git, setting up a repository, adding some code, doing some commits, sharing those commits back up to VSTS, doing a Get Latest, a fetch and a pull or a sync, and then doing commits with related work items. Next up: Let's talk a little bit about branching and merging. 
Branching and Merging
Let's talk about branching and merging. Branching and merging, it's a feature in source control, and it's available in Git and TFVC. It's available in a lot of other ones too, but since this is a VSTS course, we'll talk about the two version control providers that are available in VSTS. So, whether you're using Git or TFVC, it's there. Branching and merging are available in both of them. It's basically a smart copy, and that smart copy is called a branch. And what that branch lets you do, what that smart copy lets you do is work on similar versions at the same code, but you're going to work on them isolated from other people on your team or maybe even isolated from other stuff you're working on just for yourself. Whatever it is, you work in isolation in that branch. And at a certain point, you're going to probably integrate those changes. So since it's a smart copy, version control knows how to move stuff back and forth between the branches, where it came from, where it's going to. So you can at some point integrate, or maybe you never integrate. And that integration is called a merge. Merge is synchronizing those two smart copies together. And that's all done via the source control provider, Git or TFVC, whatever you're using, and it manages the relationships. It knows what needs to go where. So next up: I'm going to do a demo. I'm going to show you how to do branching and merging in Git. 
Demo: Branching and Merging with Git
So let's do a demo of branching in Git. So I'm going to take our Git repository, create a branch off of the Hello World code in Git. I'm going to discuss the difference between local branches and remote branches, eventually publishing our branch up into VSTS. We'll make some changes, and we'll merge the changes between those branches. Here we are in Visual Studio in our HelloWorld sample. Now let's say that we want to create a branch because we're planning to make some changes to HelloWorld. Let's say we want to do HelloWorld and say what time it is. And let's just pretend even though that's not that big a change, let's pretend that that's actually a bigger change than it really is, and that we want to do this isolated from our other software developers in its own branch. So we need to create a branch, and if we're doing this through Visual Studio, what we do is we come into Team Explorer, click on Home if you're not already there, and you've got this section that says Branches. Click on Branches. And right now we can see that we're on the master branch. And we can see that because it's the selected bolded version. We also can see that in the lower right-hand corner of Visual Studio, it says we're on master. So we want to create a new branch, so I'm going to click New Branch. And let's call this hello-world-with-time. So we've got this populated. Let's click Create Branch. We've got the branch. We're now in the mode of using this branch. And we can see that because it's bolded, and we can also see that because of what it says in the bottom right-hand corner of Visual Studio. At this point, let's go add a couple of files in here. Right-click, we'll say Add, and we'll add a class. And I'm going to call this TimeDateProvider. I'm just going to type some code in here, implement a little method that says GetDateTime. And we'll get the date for UtcNow and return it as a string. Now let's come over to our Program.cs file. And we'll come over here, and we'll say new TimeDateProvider. And that's that change right there. So we've done some stuff in here. Let's go ahead and commit this. Implemented time provider in hello world. Let's say Commit All. We'll save our changes, and there we are. We've committed our change to the hello-world-with-time branch. Now let's hop up to the web interface. So through the web interface, we can view what branches there are. And we can do it from the branch menu. If we pull the branch menu and then click on All branches, it shows us a list of branches. Now, what we're seeing right now is we only see master. But we've got that other branch. Where is it? Well, remember, there's a difference between what is local and what is remote. So right now, the branch we created is actually just a local branch, which means it only exists on our machine. So if my laptop gets run over by a dump trunk right now, that change is gone. It hasn't been backed up to the server. No one else can see it. It's only on my machine. So let's change that. So let's come down here. Let's click on Home, on Team Explorer, and go to Branches. And here's our branch, hello-world-with-time. And notice there's just a little bit of a difference in the icon between master and hello-world-with-time. That icon means that it's a local branch versus a remote branch. So if we want to be able to share this and the changes we make in this branch with the server, we need to right-click on it and say Push Branch. So that pushes that branch up to the server. So let's go back to the web interface, refresh this view, pull the branch, master and hello-world-with-time. So if we click on hello-world-with-time, click on History, we can see we've got that change, Implemented time provider in hello world. If we go back to master, that change doesn't exist. So let's say that we're just about done. We want to merge our changes from hello-world-with-time back to master. Usually you'd probably do more than just one commit that you'd merge, but let's just pretend that we're done implementing this thing, and we want to share our features back to master. What I would recommend is go to Branches, double-click on master to switch into the context of the master branch. If we go to Solution Explorer, we see that our TimeDateProvider doesn't exist. And if we look at Program.cs, none of that code is there. So back on Team Explorer, right-click on master, choose Merge From, and then it's going to ask us where we want to do our merge from. So I want to merge from hello-world-with-time. Choose that, click Merge. And now our changes have shown up here. And let's just say that as part of this, we also want to make one little change. We'll say Hello World, print out the DateTime, and then YAY! Come over here, and we're going to say Commit, and we'll say Added "yay!". Commit All. And now we've got some stuff that needs to go back up to the server. Let's go over to the Synchronization section. And for our outgoing commits, we don't just have our Console.WriteLine("YAY!") change, we also have the stuff that we merged back from the other branch. So at this point, if we're happy with it, we can share it back to the server. So let's just click Push. So that's the basics of branching and merging and publishing branches up to VSTS. Next up: Let's talk about doing code reviews. 
Code Reviews
Let's talk about code reviews. Now code reviews are not the most exciting thing in the universe, but here's the basic idea. Somebody writes code, they make a bunch of changes, and then before you say it's done, somebody else takes a look at your code. Now they might love it, or they might hate it, or they might have suggestions, or they might find errors, but the idea is that someone else looks at it, and that usually ends up meaning that it's better code at the end. Now in VSTS and TFS, when you're doing code reviews, it's very, very closely related to version control because you're code reviewing things that happened in version control, code changes. In TFVC if you're using that as your source control provider, then code reviews are called code reviews. And just to be fun, in Git, they're called pull requests just to make it confusing. Next up: I'm going to do a demo of doing a code review with a Git pull request. Now I'm not going to be doing a demo of the TFVC code review flow in this course. And you're probably asking, So why am I going to skip those? Well, the easy answer is because they're super-hard to use, and Git pull requests are just simply way better. And, honestly, if you think that code reviews are going to be part of your delivery flow, that's a really strong reason for why you should use Git as your source control provider. So next up: The pull request demo. 
Demo: Code Reviews Using Git Pull Requests
So let's do a demo of a pull request. So we'll be using Git, and we're going to take some changes that I've already made in a branch, and we're going to request that these changes get merged back to the main line, the master branch of our Git repository. And we're going to do that using a pull request. And in that pull request, we're going to assign it to a person on our team, and that person's going to review the code changes and approve or disapprove and complete the pull request. So here we are. We're looking at the web version of our Git repository, and we're looking at master right now, at the master branch. If we pull the list of branches, we have a new branch here called hello-world-with-random-number. And I've made some changes inside this branch to HelloWorld. I've added a class called RandomNumberProvider.cs. And then in Program.cs, I've refactored some of the code. So I've taken our TimeDateProvider, renamed that into a variable, done some different things with Console.WriteLine. We've got a call into RandomNumberProvider where we output a lucky number that gets generated on the fly. If we look at History, we've got a bunch of changes that are in this branch that haven't moved back. Part of the way that I know this is that I've got this message up here at the top saying that I updated this branch, and it's inviting me to create a pull request. So what we could do is we could click that link right now, but I want to show you how to do the same thing starting in Visual Studio. You end up in the same place. So here we are in Visual Studio. If you go to Team Explorer, click on Home, one of the items you get is pull requests. Click on this. We're in the hello-world-with-random-number branch. You can see that down here. And if I click New Pull Request, it'll pop open a browser. A browser comes up, and it shows me the page for creating a new pull request. So pull requests are related to merges. It's really more of a merge request. So what we're doing is we're requesting that we merge from hello-world-with-random-number branch into master. We can provide a description, and we can say in the description Added lucky number functionality. Now down below here, we have reviewers. And by default, it's set to anybody who is on our team. But let's say we want to have it be reviewed by a specific person. So we can knock out that. And I happen to know that the person I want to review it is Natasha Nanjiani. Click Search, she comes up. If we scroll down a little bit more, we can see into the files and the commits, the changes that are going into this pull request. And when we're happy with creating the pull request, we can click Create. It then shows us our pull request, and we're looking at the Pull Requests section of the web interface. And we can see the reviewer is set to Natasha Nanjiani. So now let's go switch over to her view and see what it looks like on her side. So we have a new browser. We're logged in as Natasha. Let's go to Code and go to Pull Requests. And then right in this view, it's got Assigned to me, me meaning Natasha Nanjiani. Then we have a pull request coming in from Benjamin Day. So let's click on it. And let's go look at it. So we'll go to Files. We see some stuff here. We added RandomNumberProvider. Let's look at the changes inside of Program.cs. We can see all the stuff that I added and what it used to be. So it used to be provider, and that got renamed to timeDateProvider. Let's say that's looking good so far. Then we come down a little bit more, and then we've got our luckyNumberProvider. And now there's actually something kind of weird here. We're declaring a variable called luckyNumberProvider, but we're newing up an object called RandomNumberProvider. And then down below, we write out Here's your lucky number, and we call into the GetLuckyNumber method to get that value. So we've got kind of a violation of our naming convention. It's not---we kind of understand what's going on, but that RandomNumberProvider class is actually named incorrectly. So if we want to add a comment to this, notice that as we hover over these lines, we get that little icon on the left. That's the add a comment icon. So if we come over here and click on this, it opens up a little window where we can add a comment. And let's say, This should be called LuckyNumberProvider, not RandomNumberProvider. So we'll copy the text of that just because I want to use it again, and click Comment. So that's over there. Let's come over to RandomNumberProvider, and let's add a comment for this file. So rather than commenting on a line, let's add a comment to the file itself. So click on that menu, say Add comment, and then paste in exactly the same text. Click Comment. So at this point, we're done with our review, but we need to have these things resolved. So we kind of have to wait for the original author. So what we're going to do is rather than approve it or reject it, we're going to pull this menu and say, Wait for author, which basically goes and puts that back onto me, Benjamin Day, and I have some changes I have to do. So let's flip back over to my view of this pull request. So here's my view. And we can see we've got some stuff in here from Natasha. This is misnamed. So we don't like RandomNumberProvider. And we can see that that stuff is going on pretty good. So let's write back to her and say, Oh good point. I'll fix that in a little bit. Now I'm not going to resolve this, but I'm just going to reply. So that just sends her that message, but it doesn't say that that comment has been fixed. So let's hop over into Visual Studio, and let's go make that change. So basically what Natasha did not like was the name of the class for the RandomNumberProvider. It should be LuckyNumberProvider. Let's come over here. Let's change the name of it, change that to LuckyNumberProvider. In Solution Explorer, we'll change the file name. Let's see if it still builds. Nope, not yet. We've got a problem over here. We've got to change the updated class name. Build it again, and that looks pretty good. So, let's come in to Commit, and we'll say, Addressing issues from pull request. Commit All. Let's sync our changes up to the server. So we'll push these changes. And now let's go back to our pull request as me, and let's add some new comments. Let's say, Fixed this. Click Reply and Resolve. Fixed this, too. Reply and Resolve. And now at this point, I think Natasha's going to be okay with us. So let's go back over to her view. And one of the things we've got here is we've got this little icon that says, View all code updates. And then the Updates section. Let's click on this. So this shows us that we've got some stuff going on that's changed since the last time we looked at this. And if we look at the Update section, we've got the initial commits that went into the creation of the pull request. But then we've got the stuff that's in the commit that we modified in order to make the reviewer happy. So if we click on this, we can see what's going on. Basically we renamed RandomNumberProvider to LuckyNumberProvider. You can go to the overview for the pull request. And at this point, we're good. We're happy with what's going on. We've got our comments that have been resolved, and we're happy. So let's come in here and say Approve. We've approved the pull request, and now we can complete it. So what this'll do is this'll finish the merge. We merge the changes from the branch back into master. And at this point, we don't need that branch anymore, so we can click on Delete source branch and make that branch go away. So now that Natasha's done, let's flip back over to my view. We see on our pull request that it's now completed. We see that she completed the pull request, merged it back. And let's go back over to the files inside of our code repository, inside of Git, flip this over to the master, and let's look at History. So in History, we see we've got the pull request and the addressing issues from pull request. And if we wanted to, we can come back and look at the details of the pull request for historical value. But at this point, we have finished doing a code review using a Git pull request. 
Summary
Let's do a quick wrap-up summary of what we did in this module. So we started off just quickly talking about why version control. We went on from there to discuss the two types of version control that are available to you in VSTS. So distributed versus centralized. The distributed version control provider is Git. Centralized is TFVC, Team Foundation Version Control. We talked about the basics of Team Foundation Version Control, how to do check-in, check-out, and connect to our project. Then we switched over and talked about Git, once again connecting to a project that uses Git using Visual Studio. We made some changes, added some stuff, made local commits, pushed our commits up to the server. And we switched over and talked about branching and how to do branching with Git. And then, finally, we wrapped up doing a code review using Git pull requests. Next up: We're going to talk about builds and releases using Visual Studio Team Services. 
Building, Deploying, and DevOps with VSTS
Overview
Hey everybody. It's the Building, Deploying, and DevOps with VSTS module. Quick overview of this, we're going to start out talking about why automated builds, why automated releases, why DevOps and what this whole DevOps thing is, and then I'm going to show you how to do automated builds with VSTS, and then release and deploy pipelines with VSTS. 
Automated Builds: Why Do I Care?
Automated builds, why do I even care. Okay, well the reason that you care is because of something called the works on my box problem. The basic idea is well if you've ever written some code, you're writing code on your machine, works just fine, you check it in, you share it with someone on the rest of your team, someone else in your team pulls that code down, they try to use it, and now it's completely broken and you really can't figure out why it's not working, but your answer to why is it broken is I don't know, works on my box. So breaking that down a little bit more, it works on a developer's machine, but it doesn't work someplace else. Now usually it's because of configuration differences or some little tiny differences in the code, maybe you have some version control issues, but really what's happening here is it's integration issues, integrating your stuff with everyone else's stuff and suddenly it doesn't work anymore. Now this can be super annoying during development, but when you get to production, this can be catastrophic. If you're trying to get a smooth continuous delivery going, these annoyances, yeah you think it's funny when it happens in development, but when suddenly production doesn't work, well a lot more people can get annoyed. Bottom line, integration is a pain. Now what is this integration thing? So you bring all your code together, you get it ready to test, you get it ready to ship, and well if you only have one developer, if it's just you working by yourself, then you have practically no integration effort because it all happens on your box, works on my box problem, not really an issue because the only box that matters is yours. But when you have multiple developers, then you have probably a lot of integration effort. The more developers, the more integration effort you have. You have to bring that stuff together and make sure that your application still works. Now I don't know about you, but I think that this integration work is tedious and repetitive. It's not particularly interesting work and you have to do it again, and again, and again. Now if you had an automated build, this is why you care about automated build, the automated build is going to be a way for you and your team to know if your stuff is integrated. So here is what I do in a typical automated build. I'm going to get the latest version of the code, whatever has been checked into version code, get it, try to compile it, if it doesn't compile, that's a problem, if it compiles, I'm going to run automated tests, that helps you to figure out does your stuff actually work. Hopefully, you're writing automated tests. Please start writing automated tests if you're not doing it already. And the goal of this, if the code compiles in a test path, you've created something that's potentially shippable. In VSTS and in most automated build systems, it's going to generate a build number for you and that build number identifies what's in that build, it's a wrapper for the stuff that went into it. So what is the code that went into that? With VSTS, you can have related work items, so whatever work items you worked on that went into this build, that shows up as attached to that build number, and all this stuff gives you a nice traceability, what's happening where, what did we test, what works, what's been integrated, it's all sitting behind that build number. Now if you care about DevOps, an automated build is the start of your DevOps awesomeness. So what's this build DevOps thing? So DevOps is trying to smooth over what used to be a gigantic chasm between the development teams and the operation teams. It helps you to go faster. So when I think of DevOps, I think of it as a mindset plus a set of practices that focuses on automation. Now that automation thing, well remember I said that an automated build is the start of your DevOps awesomeness, well that's one of the first things you can automate. Automate your integration. So why do I even care about DevOps? Well if you've automated this stuff, you can deliver faster and more often and you can do it with a lot less work. Now you might not think of it this way, but it actually saves you a lot of time, makes you a lot more efficient as a development organization because what you're trying to do is you're trying to eliminate tedious and disruptive work, stuff that's done again, and again, and again, it doesn't change very often, well you're going to try to automate that and that helps you to get your DevOps flow moving faster so that you can deliver done working software more often with less work. So things that I think about as big-time savings in DevOps, one, integration, two, testing, and then three, deploying. So for your integration, that's your automated build, for your testing, that's your automated tests that run as part of your automated builds, and then for your deploys, through automated release pipelines and that gets your automated deploy. Now what is a VSTS release? I think of it as an extension of VSTS automated build and it separates the build activities from deployment activities, which is really nice because they're not meant to go together. A lot of people do their automated builds and cram it all into one, ah, that causes some maintenance problems. What you're going to do is you're going to deploy the outputs of your build and you're going to deploy it into something called environments. The VSTS release knows what an environment is, for example, dev, test, staging, production. There is also stuff baked in for doing approvals. So for example, only Gladys from HR has permissions to approve going to production. Maybe that's something you have to support. And now what you can do with that VSTS release is you can go all the way from dev to production without someone from the development team being involved. If Gladys is cool with what was deployed to test and she clicks approve, then it's going to production. There is also security that says only certain people can do certain things. And throughout this whole thing is traceability, who did what, when, and what went where. Now in this module, I'm not going to go super deep into build and release because this is an intro course, but in my DevOps Skills for Developers with Visual Studio and TFS 2017, I go super deep into this stuff. That course is about 9 hours long, all about DevOps, all about automation, and while that targets TFS 2017, well if you're using VSTS, it's pretty much the same thing, hasn't changed that much. Your skills will port. The information is valid for both TFS and VSTS. So if you want the deep dive content, go check that out. Okay, next up, let's dive into a build demo. 
Build Demo, Part 1: Tour of the Sample Application
Okay, let's do a demo. So in this demo, I'm going to create a build definition in VSTS. But before I do that, I'm going to give you a tour of the application. So the application is an ASP.NET MVC application written on top of .NET Core and it's a web-based calculator. It's not super complicated, but it's complicated enough so that we can do interesting things with it, so I'll give you a tour of that. Then we'll create the build definition, and as part of that, we'll run the unit tests and I will talk about various trigger types that are available in VSTS. I'll also give you a quick overview of VSTS build and release agents. So let's dive on in. Okay, I've got Visual Studio 2017 open and I've opened up the solution for the sample app. Now over here in Solution Explorer, there are two folders inside the solution, one is src, that contains our source code, and another folder that contains our test code. So for the architecture of the application itself, there is an ASP.NET Core web project and then I have an API project that contains some of our back-end logic. So let's run the web application. Alright, here is the application and it's a pretty simple calculator. We've got a feel for Value 1, we've got the Operator, it should be add, subtract, multiply, or divide, Value 2, and then the Result. So let's do 2 plus 5, click Calculate, that's come out to 7, we get the message, Yay! Math is so much fun! Wheee! We've got is result valid. So for example, let's do divide by 0, calculate, is result valid equals false, and we got the message, Whoa there hold up! You can't divide by 0 Champ. So there you go, basic structure of our application. And then down at the bottom, we've got this little thing that says version and that version says development meaning we're running it inside of Visual Studio in the development environment. That version that shows up, that is coming to us through appsettings.json. So in our app settings, I've got a configuration value right here that's currently set to development. We'll do some more with that a little bit later. And because I'm all about unit testing, I've got a unit test project that's got a whole bunch of tests in it for both the controller and some of the back-end logic for the application. So that is what we are going to create an automated build for. Now this code has already been put into VSTS, it's in Git, so let's open a browser and take a look at that in the VSTS web interface. So I've created a project in VSTS called ps-web-calculator, ps for Pluralsight, and here is all the source code for our web calculator. We've got the source code, we've got the test code, it's all in there. Now that you've seen the sample application and the code that's been checked into version control, in the next part of the demo, let's actually go create a new build definition. 
Build Demo, Part 2: Create a Build Definition
When we look at the Git repository, it gives us a button conveniently right here called Set up build. So if I click on that, that gets us going towards creating a brand-new build. When we go to create a new build definition, the first thing it asks us is where do we want to pull our code from. Now it doesn't have to be in VSTS. It can be in GitHub, Bitbucket, some other Git repository or Subversion even. And then, of course, if you're using Team foundation version control, obviously, it will show that as well, but I'm going to assume that our code is in VSTS, so I'm going to build from our team project, ps-web-calculator, the repository is ps-web-calculator, and the branch I'm going to build is master. Click Continue. It gives us a bunch of templates which are starting points for building a whole bunch of different code. So towards the top is the nice .NET stuff, ASP.NET Core stuff, then you have definitions for Android apps, Ant, Gradle, Jenkins, NodeJS, Xamarin, Xcode, you pretty much can build anything. You've got a lot of options. I'm going to start from ASP.NET Core. So I'm going to choose that template and click Apply and that auto-populates a whole bunch of stuff. The first thing I'm going to do is I'm going to change the name. I'm just going to change it to ps-web-calculator-build. The first thing you're going to care about is this Process section which shows you the name of the build and then you have this thing here called Agent queue. So if you pull the drop-down, you've got a bunch of different options. So an agent, a build agent, a release agent, is something that actually does the work of running your build or running your release. What's cool about VSTS is that they give you ones that are hosted in Azure that you don't have to worry about, you don't have to set them up, there is no patching, there is no installation of Visual Studio you have to worry about, you just choose it and go. Now if you want to have your own agent that runs maybe on your laptop or in some data center somewhere, you can do that too. Those are known as private agents, but we're going to focus on hosted Visual Studio 2017 agents. So I'm just going to choose that, that's going to be our default agent. Then a little bit further down, we've got the task that happen inside of our build, and since this is an ASP.NET Core application, we start like any .NET Core app with a restore, then we do a build, we run our tests, and then we do our publish. So I'm going to make a couple changes right now that just make a clean output from our build because if we don't do this, the output gets a little bit messy. The first thing I'm going to do is uncheck Zip Published Projects. So what gets published, we have the option to zip it up. Now zipping it can speed up things sometimes, but it also cuts down on your ability to use some of the nice menu stuff. Speed is not of an essence for me, so I'm going to leave my stuff unzipped. The other thing we're going to do here is I'm going to change where I publish my ASP.NET Core application. So by default, that goes into the buildartifactsstagingdirectory, and that's a variable that's resolved at runtime. When the build actually runs, that gets populated with a value, and rather than just dumping stuff right in there, I'm just going to change this a little bit so that I put the published output into its own directory, artifactsstagingdirectory\for-deploy. I'm going to grab that value and put it on the clipboard and then I'm going to move onto the final step in the build, which is publish artifact. So publish artifact takes the output of the build and uploads it to TFS. So by default, it publishes that artifactstagingdirectory, but I just want it to publish only the stuff that came out of the publish step, so I'm going to take that for-deploy directory. That's pretty much it. So I'm going to click Save, you can create a version comment on this build, click Save, and that's our new build definition. So in the next part of the demo, let's go actually run it. 
Build Demo, Part 3: Run the Build
Okay, so we've created our build definition and that build definition describes the steps that'll happen when the build executes. And now, well let's trigger this build. So we go to this menu right here, choose Queue from the menu, the interface looks a little bit funky on the small screen dimensions that we use here at Pluralsight, but it looks good on a bigger screen. Scroll down a little bit here, you've got this Queue button, clicking Queue kicks off the build. So it's created a build number, click on that, and it shows us the progress of our build. One of those hosted agents picks up our build and starts running it. Alright, so the build ran and the build succeeded. Next, let me give you a tour of what all this stuff means. So here on the left-hand side, you can see the steps that we went through when the build ran. It initializes the agent, gets the information about the job, gets the source code, does a .NET restore, does a .NET build where it actually compiles our stuff, issues a .NET test, runs our unit test, we can see right there, 19 tests pass, it does the publish, then it publishes the artifacts of the build up to VSTS. Now what's that artifact? The artifact is the published output of the build and you can view it by clicking on the build number link that's in the upper left-hand corner right here and clicking on that link brings up the build summary and the artifact is part of the build summary and the build summary is the overview of the build. So we can see down here, we've got the associated changes, these are all the Git commits that went into this. We have the information about when it started, when it finished, and where it ran, what queue did the build. And then we have this Artifacts tab, click on Artifacts, and what we can do is we can click on Explorer and look at what got uploaded. So the artifact is commonly referred to as the drop. So if we expand the folders in the drop, we can see that we've got the published output of our ASP.NET Core application. Basically, at this point, it's ready to be deployed. This is everything we need to do the deploy. Now we're not going to deploy it here out of the build, we'll create a release later on in this module that'll do that. Now that we've run this build and you've seen what it does, next we're going to go back to the build definition and I'm going to show you a couple other things you might care about. 
Build Demo, Part 4: Artifacts, Triggers, and Variables
Next, let me show you a little bit about the innards of the build. Now let's go back and look at the build definition. So we can click on the Edit build definition button and we're back to a list of steps for our build. Now down here in Publish, we've got a couple of variables that get used right here. So that artifactstagingdirectory, BuildConfiguration, any of these things that inside of $ parentheses get replaced at runtime with actual values, which takes us to the Variables tab. Those variables we referenced earlier are actually predefined variables. So if you click on this link right here, it takes you to the documentation for VSTS and Team Foundation Server. So there are a handful of variables that are defined just automatically, they come with the build system. So if you want to read up on that, go to variables, click on Predefined variables. You also can define your own variables, so click on Add MyVariable123, give it a value, My Variable Value, and if you want this to be encrypted, you can click on this little link right here, which changes the variable to type secret. I'm going to delete that variable because we don't need it right now. We have BuildConfiguration right here, so right now it's set to release, but if you want to have a debug release, you could change this to debug. I'm going to leave it as release mode. If you want a whole lot debugging out of your automated build, change system.debug to true and leave that turned on and that's a basic overview of variables. Next up, there is this tab that says Triggers and a build trigger describes how a build gets started. Right now, it's set to start manually. You also can do based on a schedule or you can do something called continuous integration, which every single time somebody checks in code, Git starts a build. So if I check that and save the build, then every time someone checks in, this build will automatically run. So that's a quick tour of creating an automated build. Next up, let's do some demos of VSTS releases. 
Release Demo, Part 1: Create a Release Definition
Alright, in this demo, we're going to create a release definition in VSTS, which is going to take our application, take the output of that automated build that we just did, and deploy it into an Azure app service. So in a previous module, we talked about how there are all these extensions for VSTS and TFS and you can get them from the marketplace, marketplace.visualstudio.com. I'm going to be using some stuff that I created that I have published up in the marketplace that comes from my build and release tools. So if you go to marketplace and search for it, you'll find it pretty quickly, or you can go to the URL at the bottom of the screen, they're free, install them into your VSTS account and it will help you out with your builds and your releases. So before I dive in to create a release definition, I want to show you what I'm going to be deploying into in Azure. So here is the Azure portal for my account and I'm going to go to App Services and I have created an Azure app service web app called ps-web-calc, click into this. Okay, so this is where we're going to be deploying to. An Azure app service web app, also known as webapps, is a service for hosting web applications. Basically, you create one of these in Azure, create the definition for one of these in Azure, and then Azure takes care of the details of the virtual machine that it actually hosts your app. You don't actually see it, you don't have to worry about that, and then there is a whole bunch of features that help you to do things like scaling load balancing, redundancy, all those fun details. So we're going to deploy into this and it makes our lives really easy. Let's head back over to VSTS. So here is the output of the build that we ran, and remember that if we click on Artifacts, we have the output of the build and this is the stuff that we want to deploy off to Azure. Conveniently enough, there is this button right here in the build summary that says release. If you click on that, it takes you into creating a release definition and we're going to do an Azure app service deployment. So we'll choose this as our starting template and click Apply, and the first thing it shows us is this environment here. Now one of the things that's nice about automated releases with VSTS release definitions is that it knows about environments. Now probably for any application you work on, you probably have a development environment, a test environment, a staging environment, production environment, something like that, right, and when you're deploying your code, it's going to move through those environments. So let's give this environment a name. Let's call it test. This will be our test environment and you see that it changes the environment box right here, and then if we click on this little link on the test environment, this shows us the test detail of our release definition for the environment. It looks an awful lot like an automated build, doesn't it? It's pretty close. It's basically the same stuff under the surface. Since we're deploying into Azure, we need to choose our subscription. I'm going to choose Microsoft Azure Sponsorship. Then you have to authorize this, so click Authorize. Behind the scenes, VSTS goes and talks to Azure and now it's authorized. Then we can choose app type, our app type is going to be web app and then app service name, pull the drop-down, and it's populated with our app services, and since we're going to deploy to ps-web-calc, I'm going to choose ps-web-calc. So right there, we're starting to link this environment up with that Azure subscription and our deployment target. Next, we'll come over to the Deploy Azure App Service step, and if we scroll down a little bit, we have this option right here that says package or folder, this is what are we going to try to deploy. Click on the  button, and it shows us our linked artifacts for our release. So remember that our build is being deployed by our release so it shows us the output of our build, shows us our build drop, and I'm just going to say deploy everything in Benday.WebCalculator.WebUi, so choose that, click OK, and that's pretty much it. So I'm going to hit Save. Okay, so we now have a release definition created, and in the next part of the demo, we'll run it and deploy our application to that environment. 
Release Demo, Part 2: Run the Release and Deploy to Azure
In the previous part of the demo, we created our release definition and now we're ready to go, so let's actually run it. So go to this Release menu, say Create release, you pretty much can accept the default, so go to the bottom and click the Create button. In the upper left, you've got a link that says Release-1 has been created, click on that, click that, and it shows us our release in progress. If you want to watch it live, click on the Logs tab and you can see exactly what it's doing. The release is completed, and now if we go to the URL for our app service, it should be running. So let's open a new tab, paste in the URL, and there is our application. But down here at the bottom where it says version, it says development so far. Wouldn't it be nice if it actually told us something about the release and the build that was in there? Yeah, okay. So let's do that next. 
Release Demo, Part 3: Edit Configuration Details as Part of the Release
Okay, so we've created our release definition, we've run it, we've deployed it to Azure, and it's working, but we've got this thing right here, the version that says development and we want to update that as part of our release definition so that it shows us information about the build and the release. My point with this part of the demo is to show you that release definitions aren't simply about dumping bits of your application onto servers, I mean, that's a big part of it, but in real life, you'll probably also have to do some other stuff like editing configurations and well, in this demo, that's exactly what we're going to do. I'm going to show you how you can use a release definition to edit configuration information. So to change that value for the version, we need to modify appsettings.json in our deployed application because the application reads that value out of that config file, puts it on the screen. So let's go back to our release. Here is our release definition, hover your mouse over it, click the Menu button, and then from this context menu, choose Edit, and that'll take us into the release definition editor. We've got our test environment, and in order to modify the configuration values and appsettings.json, we're going to need to add some new tasks to this environment. So to get started on that, we'll click on this link right here and that'll take us in and show us the current task for this environment. Now what we're going to do is we're going to modify that appsettings.json file before we do our deploy. So let's come over here and let's add a task. I'm going to go to Utility, scroll down a little bit, and I'm going to choose my Set string value in a JSON file activity, choose that, click Add, and now let's take that and drag it so that it happens before the deployed it as your app service. So this task is free, download it from marketplace.visualstudio.com, and what it does is it helps you to edit JSON files. So right here, we have to choose the JSON file we want to edit, so let's just drill into the build output, choose appsettings.json, hit OK, and let me show you what this JSON file looks like right now. So here we are in Visual Studio, it's inside the web UI project, open up appsettings.json, and that's where that value comes from, CalculatorSettings, BuildVersionMessage, so let's set up that task to edit that. Our first level value is going to be CalculatorSettings and our second level is going to be BuildVersionMessage, and actually, let's change the display name for this step. Let's say Update build version message, scroll down a little bit, and now we can set the value. So the value can be anything we want it to be and I'm going to set it to this. Now let me walk you through it. So I want it to say what build it came from, so right here, we're going to use a variable value that describes what the build number was for the artifact that we're deploying, this is automatically generated for us, then I'm going to say what is the ReleaseDefinitionName and then finally, Release.ReleaseName and that's going to be the actual release number that did the deployment. So once again, if you want some information about what variables are available to you, you can go to the Variables tab, either define your own or go look at the Predefined variables that are available to you. Back to Tasks, come down here, that's pretty good, so let's hit Save, Updated build version message, hit OK, and let's kick off a new release. So we'll go to the Release menu, say create release, choose the defaults, click Create, and now Release-2 has been created. Alright, the release succeeded, so let's go and refresh the application. Alright, so that version is now populated, but there is an error. What I pasted in is not correct, so if you see something that looks like that, that means that you referenced a variable that doesn't actually exist. So I think that what it is that the name of the artifact we're deploying is not exactly what I think it was, so let's go back and fix this. Go back to the release, click Edit, and let's look at artifacts. So artifacts are what we are actually deploying and each artifact has an alias name. So source alias is ps-web-calculator-build, let me grab that, put it in the clipboard, and let's go back over to our environment, come over here to our Update build version message step, come down and yep, I've got the slightly wrong variable name. Change it to reflect the right name of the artifact, and let's save this, and run a new release. Now we're on Release-3. The release succeeded and let's go back over and refresh the app. This time, that build version message shows us the right value, something that we expect and it's very descriptive. So it says it deployed that build number from that release name and that release id. So there you go, we've got our release definition and it deploys us into Azure. So far in this demo, we have a release that deploys into a single environment, but in real life, you'll probably have more than one environment. You're probably going to test in a test environment, and when you're confident the application is working, you'll deploy into something like a production environment. In the next part of this demo, I'm going to show you how to do that. So next up, multiple environments and pre-deployment approvals. 
Release Demo, Part 4: Multi-environment Releases and Approvals
In this demo, we're going to add environments to the existing release, and in that new environment, what we're going to do is we're going to deploy our application into an app service deployment slot, that'll let us have multiple environments, so we can have a test environment to deploy into and then a production environment to deploy into so that we can do some testing before we deploy the real version of our application. And then after we have that new environment set up, I'm going to show you how to add an approval to a release. This means that a user has to look at that application and say yes, I'm happy, and I'm ready to deploy this to the next environment before it actually goes there so it won't automatically deploy to that environment, it requires a human to look at it and say yes, I want to do this. So multiple environments, deploy a known app service slot, and adding approvals to a release. Here we go. Alright, so we have a basic release working and it deploys to our test environment. Now one thing I'm going to do is I noticed that the name is kind of ugly. I'm going to change that to ps-web-calculator-release. And right now, we have just one environment that deploys to test, but let's say that we want to do a deploy to test and then if that test environment, if the application looks good there, then we want to deploy it to production. So deploying to production is going to be pretty similar to what we're doing for deploying a test. So we have a couple options, we can either come in here and clone the existing environment or we can just create a brand-new one. I'm going to choose new environment and start from a template. The test environment is app service environment deployment, but I want to do something based on Azure app service deployment with slot. So slots in Azure app service kind of help you have one definition for your app service, but then multiple places you can deploy into and it helps you a lot with stuff like this, having a test environment and a production environment. So I'm going to start from there and let's call this production, and right now, production is a peer, a sibling to the test environment, but that's not really what I want to do. I want production to happen after we've gone through test. So if we come over here and click on this little button on the left side of production, we can change the trigger and the trigger we want is the after environment trigger. So I want this to run after test is run. And now that changes it up a lot so that now you have to go through test before you get to production. Let's come down a little bit more. One of the things you can do is use something called pre-deployment approvals. So a user has to actually approve the deployment to this environment before it actually goes. So we'll turn on pre-deployment approvals and I'm going to put in my name, choose Benjamin Day. So what this means is that after a deployment happens to the test environment that I'm going to get an email notification and a notification in the web interface asking if I want to do a deploy to production. So that there, that's called an approval. If I say yes to the approval request, then the deploy to production runs, and if I say no, then the deploy doesn't go to production and it stops in test. And that's pretty good right there. Now before we can start jumping in on this, we need to actually create a deployment slot in Azure. So let's come back over to the Azure portal, here is our ps-web-calc app service, and over here on the left, we've got Deployment slots. We don't have one right now, so let's define one. So I'm going to say add slot and I'm going to create a slot called test and I'm going to clone it off of what we have right now. Hit OK, and there is our new deployment slot, and if we click in on it, we see that it gets its own URL, it is separate from the main production version of our web app. So if you think about what we've done so far, at the end of the last demo, we're really just deploying into production. These deployment slots are kind of slick because you can do something called a Swap. Click Swap and you can swap test for production and it just does some magic in now what was a test version is the production version, which is kind of cool, and that's what we're going to do from our release definition. We'll implement that in the next part of the demo. 
Release Demo, Part 5: Run a Multi-environment Release with Approvals
In the last part of the demo, we configured Azure to prepare for our multi-environment deploys. Now let's hook it up to the actual release definition. So we're looking at the release definition, let's go to the tasks for test. We're going to modify the Deploy Azure app service, scroll down a little bit, and we're going to check Deploy to slot. It gives us some new options. Now let's populate these options under the slot to deploy to. Now test is going to deploy into the test slot and that's pretty good right there. Now let's go modify the production environment. So we'll go to Tasks, Production, and actually as part of this one, we're not deploying anything at all because if the approval works for the test environment, we're just going to make the test environment the production environment. So we're not deploying anything, so we'll just disable the deployment part of this leaving us just with the slot swap. Now when we look at that slot swap step, that's actually kind of hard to say, when we look at that, we see that the Azure subscription box is empty, that box is also grayed out, meaning it's not editable. Now Microsoft is trying to help us out by making some stuff easy, but actually I found this a little bit confusing. Why can't I choose a subscription here? Well it's because those settings are actually set at the environment level, and to update that Azure subscription information, we need to click on the environment box and that's this thing right here. So we'll click on that and we'll do that same process we did before. We'll choose the Azure subscription that's going to run our stuff, click Authorize, alright, we're authorized. So we'll select the app service and that's going to be ps-web-calc. Then we've got a couple more required fields here so we need to specify the resource group and slot, that'll be test, and then let's come over here to the slot swap and this should be already populated. So it's going to do a swap between test and swap it with production. We're good, so let's hit Save. Let's go back to the pipeline. So we're going to kick off this release. It's going to start by doing a release to test, then it's going to pause, it's going to wait for my approval, once I approve it, then it will go to production. So let's go do that process right now. So I'll say release, create release, Release-4 has been created, and we see that the test environment deployment is in progress. Alright, that succeeded and we see this message right here saying that a pre-deployment approval is pending for the production environment. Now I'm not going to approve it just yet, I want to go do a little bit of testing. So let's take a look at what's in production at the moment. So the key thing here is to notice that this is the version that's deployed to production right now, so it's an old version, but let's go look at what's in the test environment. So we'll pop open a new tab, paste in the URL for the test environment, and there is the message right there. So the application is running and it says that it is build 20180224.1, it was from the ps-web-calculator-release, Release number 4, which is exactly what we just ran. So let's test it a little bit, 2 minus 4, click Calculate, -2, yep, that looks good to me, and we're good to go to production. So before we go to production, I want you to pay attention to that version number right there. Now the important thing to remember is that right now before we've approved that new release to production that production is currently at Release-3. Now let's come back over to the release and we have the approval waiting and it says pre-deployment approval is pending for production environment. I'll type a comment. Yep. That looks great! We have the option to defer this deployment to a different time, but I'm going to do it right now. So I'm going to click Approve and that starts the production deployment. The production deployment succeeded, and if we look at the logs, we can see that we have the test environment and the steps that it went through and then the production environment with my pre-deployment approval and the Azure app service slot swap that ran. So now if we go over to our production version of the application, if we refresh the production version of the app, it should show us a new version of the app. So let's refresh this and there you go. There is that version of the application. So basically, we did an automated build, test, and deploy with VSTS and this is the start of your DevOps awesomeness. 
Summary
Alright, summary of what we did in this module. We started out talking about why automated builds and the reason for automated builds is that it automates your integration process, brings your code together, compiles it, runs tests, make sure everything is working and it helps you out a lot by avoiding the works on my box problem. Next, we talked about why automated releases and automated releases help you to deploy stuff automatically and frees you up from the tedium of having to do that release stuff yourself. Your releases are pretty much the same every single time you do them so why not automate them. That gets you going towards DevOps awesomeness and DevOps is about eliminating the tedium so you can deliver your code faster with less effort, capture feedback really fast, and just make you better at delivering done working software. Showed you some demos of automated builds with VSTS, showed you creating a release definition with VSTS, and there you go. That was what we covered in this module. Next up, in the next module, I'm going to show you how to use VSTS to manage your project and manage your teams. 
Managing Your Projects & Teams Using VSTS
Intro
Hey everybody. This is the Managing Your Projects and Teams Using VSTS module. Quick overview. We're going to be talking about how to do project management with VSTS and a lot of this revolves around something called a work item. So I'm going to talk about what is a work item, and then after that, we're going to do an awful lot of demos. Now one of the things I didn't mention here because it's not going to be in this module is a lot of stuff on theory of project management. If you care about that, if you want to learn more about project management with VSTS and you want to learn more theory, check out my DevOps Skills for Developers with Visual Studio and TFS 2017. Head off to the DevOps Mindset and DevOps Metrics module and the Planning and Tracking Your Team's Work module. If you're interested in learning Scrum specifically, go check out my Scrum Master Skills class, that's also in the Pluralsight library. That'll get you going on not just how to be a Scrum master, but really understanding the innards of Scrum and why you do it, how to be successful, and how to avoid some of the typical pitfalls. So let's dive in. 
Work Items and VSTS Project Management
So project management with VSTS. VSTS helps you to manage and track your work, which is the essence of project management and it does this using something called work item tracking. Work item tracking is the overall system for tracking little pieces of work and those pieces of work are called work items. Now remember when we went to go create that new project and we got a form that looked kind of like this. It asks for our project name, description, what version control type we wanted to use, and then at the bottom, we had that thing that said work item process. So this is the beginning of where work items start to become relevant because what this is doing is it's asking you to choose your process template, and out of the box, well not out of the box, but by default, you get Agile, CMMI, and Scrum as your available processes, and which process template you choose determines the initial structure of your project, which is a way of saying, which work item types do I get. Now for example, the work item types in the Scrum process template, you're going to get product backlog item, task, bug, impediment, test case, feature, and epic. Each of these has their own set of fields and their own rules and it's governed by something called a Work Item Type Definition, WITD. It's highly unlikely that you will never interact with the WITD directly, but here is what it is. It's a list of all data fields for the type, for the work item type, description for how those fields are displayed in the screen, and any rules that are related to the data. All work item type definitions have a set of common fields. Some of those common fields will be title, assigned to, and id. There will also be fields that are specific to that work item type definition. So the work item type definition describes what a work item is, what the fields are. Now this work item type definition can be customized. I'm not going to get into that in this module, but just know it, they can be customized. So if you want to add your own fields, if you want to change what some of the rules are for the data, you can do that. If you want to add your own completely new work item type definition, you can do that too. Now back to this project management idea, VSTS helps you to manage and track your work and it's going to do this through work items in the work item tracking system. So typical work item project management tasks that you'd do in VSTS, create and manage requirements, manage and track tasks for each requirement you might have, assign stuff to team members, track bugs and defects you might find, track the status of your work, track of the status of requirements, track the status of tasks, track the status of bugs, and then also visualize the overall state of the project. I mean, that's a lot of what project management does, tries to figure out are we on time, are we going to deliver this thing, are we in trouble. So visualizing the overall state of the project, that's a huge part of what project management is all about, VSTS will help you do that. So enough talk. Next up, let's start doing some demos. 
Demo: Work Items and Work Item Queries
Okay, so in this demo, I'm going to show you some very basic stuff that you can possibly do with work items. We'll get into more advanced scenarios a little bit later on. So we're going to create some work items, I'm going to do a demo of a work item query, and then show you a little bit about notifications as it relates to work items. Alright, so here we are in the web interface for VSTS and I'm in a brand-new project that I called work item demo. I've gone to the work section of the project, so you click on that Work link right there, it takes you into this screen. Now under work, there are two different sections, Backlogs and Queries. Right now, we're going to work in queries. If you're in the Queries tab, you're working directly with the work items. There is practically no handy dandy details or utility features that help you to do things. This is just raw access to work items. If you click on backlogs, you start getting some tooling. I'll demo the backlog stuff in a later clip in this module. So let's start off by creating a couple work items. So let's go to New, pull this menu and it shows us the work item types that we can create right now. I'm going to create a task and it puts us right into the title box. So every work item has to have a title and I'm going to call this Task A. I'll click Save, and as soon as I click Save, I'm assigned a work item id. My work item id for this one is 3. That value is generated by VSTS. Now there is some other stuff that you can do inside of work items if you want to create a description, type in do this thing. You can bold it, italicize, underline, you can add links into this. You can add pictures, you can do formatting, you can do bulleted lists, numbered lists, there is all kinds of stuff you can do in here. Every time you make a change, don't forget to click Save. As you make modifications, if you go to the History tab, it shows you a list of changes that you made. So first off, we created it, it shows us the initial values, then we change the description, modify that to be that value right there. So history helps you to keep track of what has happened in this work item. Work items also have state. So for tasks, the state values that you can put in are done, in progress, removed, or to do. I'm going to say this is in progress. Click Save, look back down at history, we've got our state graph that says that we went from to do to in progress. Alright, let's create another work item, create another task, call this Task B, save it, put that also into in progress, and then I'm going to create a couple other ones. I'm creating work items so that I have test status so that I can do some query demos. Create Task C, I'll leave that in to do. Task D, we'll make that done. Also with work items, we can assign them to people on our teams. So right now, it says unassigned, but if you come over here, click this drop-down, let's assign this one to Natasha Nanjiani. We'll save that off and let's take some of the other recent work items. Task C, let's assign this to me. Task 4, let's also assign this to me and that's pretty good right there. Okay, so down below, we've got My Queries and Shared Queries. If you open up shared queries, there should be stuff in there. These are known as work item queries. Work item queries are kind of like select statements against your work item database. So let's create our own work item query. Let's come up to New, we'll say New query, and well this query right here should bring back everything. So let's click Run and we get back Task A, B, C, and D. We can see who it's assigned to and we can see our state. Two are in progress, one is in to do, and the other one is done. If we like this, we can save it, so click the save query as and let's say All Work Items. So now let's modify this query. We'll create a new query which will show us all the work items that are in progress. So we've got the state value right here and we'll say value, in progress, we can run it, that brings back just the two. Let's say save as, all work items in progress, so we've got that query and that query. Now one thing you might have noticed is that when we save these queries it went into a folder called My Queries. Anything that is in my queries is only visible to your user account. If you want to share it with somebody else, you need to move it into the Shared Queries folder. So you can do that by just dragging and dropping. And now the all work item query and the all work items in progress query are available to anyone who can get into this project. So from these work item queries, you can double-click on the work item, that takes you into the detail view and you can edit it. So if we move this from in progress to done and then save it and then go back to all work items in progress, it's there right now, let's hit Refresh, now Task A disappears. Now let's double-click back into Task B. Now one of the handiest features in VSTS is this thing right here that says follow. If you click on Follow, whenever anything happens on Task B, you will now be alerted. You'll get an email notification saying something has changed on this work item. So let's make a modification on this. Let's come over to details, let's provide a new description, click Save, and now let's take a look at my email. Here is my email and I have nothing in here. So why didn't I get a notification. Well, the reason you're not getting a notification on that is because VSTS assumes that if you made the change, you don't need to be notified about the change. So let's log in as Natasha Nanjiani and have her make a modification on one of those work items that I'm following. Okay, so I'm logged in as Natasha Nanjiani and I'm looking at the work item demo. So I'm on the Query page, and if I open up Shared Queries, I'll get the All Work Item queries, and I know that I, Benjamin Day, am following Task B. So if somebody comes in and modifies this, let's change the remaining work to 40 hours, change the activity to deployment, modify the description, and then click Save, now I, Benjamin Day, should get a notification in my email and I'm getting that because I followed this work item in my account and then someone else made a modification. So let's go flip over to my email and here we are. We have something in the inbox from VSTS. So Task B, remaining work is changed to 40, it was changed by Natasha Nanjiani, the description changed as well, and the activity changed. Now if we want to, we can click view work item, that'll take us right back into the work item again. So this is really helpful for maintaining situational awareness. So if there is specific stuff that you care about that you always want to be notified about and if there are modifications, just click that Follow button. Alright, that's our basic demo of the work item tracking system. Next up, let's do some Scrum with TFS demos. 
Scrum Demo, Part 1: Manage a Product Backlog
Okay, here's another multipart demo. So we're going to do a couple demos in a row and they're all going to be related to Scrum with Team Foundation Server. So Scrum is a project management methodology, it's a way of delivering done working software, and if you're interested in learning about Scrum, check out some of my other classes in the Pluralsight library. So in this first demo of Scrum with VSTS, I'm going to show you how to use work items to manage a product backlog. Okay, here we are inside of our work item demo project and we're in the same place we left off after the previous demo. So we're in the raw view, the Queries view of the work item tracking system in VSTS. Now if you want to do Scrum, you can do it just with this view, but it's kind of a pain. So there are some nice tools that VSTS gives you that helps you to do things that you would do if you were managing an Agile or a Scrum project. So to get there, you're going to click on Backlogs. And if you're not already there when you get on the Backlog page, click on Backlog items and that'll show you your Product backlog. In Scrum, the product backlog is your wish list of everything that might ever be delivered inside of your project and it's ordered so that the things at the top of your product backlog are the higher priority items that you're going to do first. So your product backlog, if you chose the Scrum template, the work item type is going to be product backlog item. You can do this exact same thing if you chose the Agile process template, but the work item type is going to be user story. User story product backlog item, pretty much the same thing. Alright, so let's go and create a product backlog item. The first thing we're going to do is click New. We get this nice little dialog right here, our work item type is already chosen for us, product backlog item, and let's give it a title, Update payment system to convert USD to Bitcoin. You can either hit Enter or you can click the Add button and there is the first work item in our product backlog. So let's create a bunch more. Okay, so I've gone and created a bunch of product backlog items, and like I said, your product backlog is word by priority. So the things that you're most likely to do first or you want to do first, the things that are top priority to your business, those are towards the top. So to do that, if you want to change the order on these things, all you have to do is drag and drop. So let's say that Upgrade site layout to support Edge is your top priority item, drag that to the top, let's say that mark transaction for fraud audit is your second priority, drag that up, that shows up nicely. Now one of the things you will probably do with your product backlog items is that you're going to estimate these and you're going to put a level of effort on them. Right now, the effort column is empty. If you want to update the effort or any other field, double-click on the row, that'll bring up the editor, you can supply description on this, acceptance criteria, you can assign it to somebody, you can have a discussion about this work item, you can do all kinds of stuff, but as far as effort goes, let's just give it an effort. Oftentimes in Scrum, you're estimating these in the Fibonacci sequence and using a technique called story points for estimation. So 13 is 1 of the values you might use, so I'm going to give this a 13, so don't worry about what that means right now, that's kind of out of scope for this class. If you're interested in story point estimation, check out my Scrum Master Skills class in the Pluralsight library. I go into that in extreme detail. Alright, so we've given this an effort of 13, let's click Save and close and let's plug some estimate values into the rest of these things. Okay, so everything now is estimated, and once you have that estimate, you can start doing something called forecasting. So let's go up here and let's turn forecast to on, and what this is doing is it's using something called velocity. Velocity is a way of representing how much functionality your team can deliver on a per sprint per iteration basis. So if your team managed to get upgrade site layout to support Microsoft Edge done, that would be a velocity of 13. So using this forecasting thing, we can change the velocity and it draws lines around when it thinks or most likely to pick up the various work items that are in our product backlog. This helps you to answer questions about hey when am I going to get my stuff, when are you going to deliver a particular feature to me. So if you change the number to be higher, then there is more stuff in each of those sprints. If you change the number to be lower, there is less stuff in each sprint and this is just used as a guideline for you. Another thing that can be really helpful is organizing your product backlog by feature. I typically think of a feature as a larger collection of product backlog items that might be delivered together. So let's go over here and let's add a couple features. So very similar user interface. So I'm going to just add some features right now. So I've got payments, shopping, account management, and administration. So let's go back over to backlog items and use these things. I'm going to turn the forecast off and let's turn parents to show, and right now, this thing is saying unparented backlog items and everything is unparented meaning that none of these things are related to a feature. If you want to map these into a feature, turn mapping on. That shows you the list of features on your right-hand side and then you can sort these things into the various buckets to relate them to the features. So upgrade site layout, that's a shopping feature. So as soon as we drag that PBI and drop it on top of that feature, it changes it and says now that it is parented. Let's take this Bitcoin one, this one is related to payments, fraud audit is administration, suspend user account is administration, update payment system for Apple pay is payments, PayPal is payments, fix layout on Safari for iPhone X, iPhone 10, that's shopping, generate report is account management, and request PDF receipt for past transaction is account management. So now that we've sorted those through, we don't have any unparented backlog items. We've got our features, and under each of these features, we see the product backlog items that relate to that feature. This feature to product backlog item thing can be really helpful once this product backlog starts getting really big. So I'm going to turn mapping off, turn parents off, and there you go, there is our product backlog. So in the next part of our Scrum demo, I'm going to show you how to plan a Scrum sprint using VSTS. 
Scrum Demo, Part 2: Plan a Sprint
In the next part of our Scrum with VSTS demo, I'm going to show you how to plan a Scrum sprint using VSTS and work items. So here we are in our product backlog and well this backlog represents what we want to do roughly in the order we want to do it. And in Scrum, what you're going to do is you're going to work in a series of sprints. Now the sprint is a period of time within which you're going to do a bunch of work. So you choose what you're going to do and you do it inside of this sprint and a sprint is typically 30 days or less. On the left-hand side, we've got this thing that says Sprint 1, 2, 3, 4, 5, and 6. Let's go look at Sprint 1. So right now, there is nothing in our sprint. We haven't assigned any work into it, we haven't moved any work items into this sprint. We also have this thing up here that says no iteration dates. So sprint has a start date and an end date, so let's go populate some dates. And then you can choose a start and end date. I'm going to do a 2-week sprint, starts on Monday the 12th and ends on Friday the 23rd. Click Save and close, and now we see that we've got 10 working days for this sprint. Now another thing that you're going to care about a lot when you're doing sprint planning is what is your capacity and that's another way of saying who is working on your project and how much time can they give you on your project in this particular sprint. So let's click on the Capacity tab, and right now, the only person on this team is me. So we've got some options here. We could click the add missing team members, so that'll take any team members that are not currently listed in this sprint and pull them into the sprint. So I'm going to click that and that picks up a whole lot of people. Okay, so there we go. That's our list of people, and if we want to, we can say what activities they do. I'm going to leave it blank because well I don't think activity is particularly interesting. On a Scrum team, what you're trying to do is you're trying to get a whole lot of people doing a whole bunch of things, and if you pigeonhole them into just one particular activity, ah, that doesn't always work out that well. Alright, another thing is what is their capacity per day. So if you want to make it easy, just go through and say 8 hours per day per person, and as I add time per person, you can see on the right-hand side that the capacity of the team gets higher. So I already have a couple work items that I assigned to myself in a previous demo so that's why I have 40 hours out of a possible 80 hours of capacity showing up here in this graph. Now 8 hours per person might not be realistic. Let's say I only work about half day and that changes my capacity, my available time so that now I'm fully booked for this sprint. Another thing that can be interesting is how many days off does these people have in this sprint. So let's give Casey a day off. Let's say that she is off on Wednesday of that sprint. Click OK, and our team's capacity has decreased and Casey's capacity has decreased. If you want to plan for a day off for the entire team, you can do that too. Let's say that Monday is a holiday. So we've modified our capacity. Don't forget to click Save. We click save and already we see that there is some funkiness happening here. I'm already over capacity by 4 hours. We might need to do something about that. But let's go back to Backlog and this shows us the backlog for our current sprint, and right now, there is nothing in it. So let's go back to our product backlog, click on Backlog items, and let's just say we're going to do the first two items and we're going to put them into this sprint. So take that PBI, drag it onto Sprint 1, drag the second PBI, drag that onto Sprint 1. And now if we go into Sprint 1, we've got 2 product backlog items that are right there. We also have these unparented ones. Unparented means that we have tasks or some other work item in our sprint, but they don't have a product backlog item parent. So actually, I'm going to get rid of these. I'm going to highlight all three of these, right-click, and I'm going to say move to iteration, and I'm going to move it to the backlog. And now those items disappear, so unparented is now empty. So the next thing we typically do for our sprint planning meeting, now that we've chosen what work we're going to do, is we're going to say what tasks we have to do for each of things. So if we hover over the product backlog item, we see the little plus sign that shows up in the margin. If we click that, that will let us add a task and that task will automatically be parented back to that PBI, that product backlog item. So I'm going to add a bunch of tasks with not particularly descriptive titles. So I'll say Task 1 and remaining work, let's make it 30 hours. Let's add another 1, Task 2, let's make this 20 hours, and as I'm adding these, you see that the team's capacity is starting to decrease. We've booked 50 hours out of a possible 388. I'm going to add a bunch more. Okay, so I've added a bunch of tasks under each of these PBIs. In real life, the task is going to have a name that's a whole lot more descriptive than Task 1, 2, 3, 4, 5, 6, or 7. My point here is to show you how to use the work item tracking system to plan a Scrum sprint. So at this point, our team is getting dangerously close to being over capacity. So let's go add Task number 8 and let's make this 100 hours. You probably wouldn't really do that, you probably wouldn't create 100-hour task inside of a sprint, but just for the demo, I'll put that in there, click Save and close, and now we see that we are way over capacity. So one thing that you could do is you could take this and let's say well we've estimated this out, it's not going to work in this sprint so let's move this back to the backlog. So drag and drop back onto the backlog, that's out of the sprint, and now we've got plenty of time. Alright, so another thing you can do is you can assign tasks to individuals by doing drag and drop. So you can take Task 1, let's drag it to me, Task 2, give that to Casey, Task 3, we give it to Kumail, and you can see that we're starting to get a fill for how busy people are, how much work they have, and how much work the team has. Let's say that we changed our mind about some stuff and we want to bring that second product backlog item back into the sprint. So we can go back to Backlog items and we can see an iteration path that upgrades site layout to support Microsoft edge is in Sprint 1. So anything that just says work item demo means it's in the backlog as opposed to it's assigned to a sprint. So this is the one that we did some work on, we planned out a little bit, and you can see if you open that up, it shows us the tasks that are under it. Let's move this back into Sprint 1, we'll go back into Sprint 1, we're way over capacity, so we'll do what you're not supposed to do and we'll just change the estimate. Change it to 8, save and close, and now we're fine. Alright, so that is a basic demo of sprint planning using VSTS and work items. 
Scrum Demo, Part 3: Use the Scrum Board in the Daily Scrum
Continuing on with our Scrum with VSTS demos, I'm going to show you how to track progress using the Scrum board. Alright, so here is our Sprint 1 sprint backlog. And now, let's try to go visualize how much work is left. So to do this, you can go to the board, click on Board, now this shows us in the left-hand column the product backlog items that we're doing in this sprint, so we've got 2, and for each of those product backlog items we have the tasks, so Task 1, 2, 3, and 4 belong to upgrade site layout to support Microsoft Edge, scroll down and we see 5, 6, 7, and 8 and they're related to fix layout and click problems on Safari for iPhone X, iPhone 10. And across the top, we've got the status, the state for each of these. So to do means it hasn't been done yet, in progress means it's being worked on, done means it is done. So if I'm working on Task 1, I can take it, drag it into in progress, and that let's everyone know on the team that task is in progress. Let's drag Task 3 in there. Now 1 of the things you'll probably do in your daily Scrum meeting, that's your daily 15-minute meeting for the team to come together and figure out how they're doing on delivering done working software in the Sprint, they'll look at all the tasks that are in progress and figure out how many remaining hours are left on each of those tasks. So let's say that I worked on Task 1 yesterday, I might have 25 hours left on this task. Kumail might have worked on this one and he might say that he's got 30 hours left on that. And as we adjust the time estimate, the remaining work, we can see how much work in progress we've got, so 55 hours worth of work in progress. We've updated this number right here, so 115 hours are left on this product backlog item. And if I drag this to done, that zeroes that out, says there is no more remaining work on it. I can drag more in here. If we're happy with this one, we can drag it to done. And as I adjust this, it updates the remaining hours on that product backlog item. So this product backlog item is done so we'll mark it as done. Move onto the next one and you can repeat the same process. So if we're looking at the Sprint right now, we can see that we have 1 product backlog item is done and we have another 1 with a bunch of to do work and 208 hours of remaining work on it. So that's just a quick way of visualizing your progress for the sprint using the Scrum board. 
Scrum Demo, Part 4: Visualize Progress with the Burndown Chart and Dashboard
So this demo kind of extends the Scrum with VSTS demo, but really it's all about work items and visualizing progress. So I'm going to show you how to use something called the burndown chart and this is a little bit more Scrum Agile specific, and then also, I'm going to show you how to use project dashboards. These two things are a couple items inside of VSTS that help you to visualize how your project is actually going and what's going on your project. So here we are in Sprint 1, we've planned our sprint, our sprint is going, and we kind of want to know what's going on, whether or not we're on track. So we've got 208 hours in our sprint that are remaining, we haven't done yet. Are we on target? Are we behind schedule? Are we ahead of schedule? Well one of the ways that you can visualize that is using something called the burndown chart. Now you can get to the burndown chart by clicking this thing in the upper right-hand corner. Right now, it's not showing very much and it's not showing very much because well I'm recording this on one day and it's not really going to populate unless you've had a couple days worth of data. But anyway, if you click on this, it brings up a burndown chart for this sprint, so it knows what your capacity was on day number one and it knows what your capacity is remaining for that sprint plotted on a day by day basis. So what this is going to do is it's going to show you how many hours worth of work is left on each day. Now this is not very interesting because this is a demo version, but let me show you one that actually has some data. Here is a burndown chart that came out of Team Foundation Server. It's not exactly the same as what you would see in VSTS, but it's pretty close and it's enough for me to talk through what the burndown chart is about. So this is the burndown chart for a team and they've pretty much gone through their entire sprint. We've got this ideal trendline here. If you're above the ideal trendline, that means you're behind schedule, if you're below the ideal trendline, it means you're ahead of schedule. So what's happening here is that every day VSTS is adding up all of the undone remaining work inside of your sprint and it's plotting it for that day on this graph. And as you complete tasks, you should theoretically have less and less work inside your sprint. So it gives you an idea of whether or not you're on target or not on target for delivering done working software at the end of the sprint. So that's the burndown chart. You can get to it by clicking on this right here. That brings up the burndown chart for that sprint. So another thing that can be really helpful for visualizing progress on your project is the dashboards. So you can get to the dashboards by clicking on Dashboards and here is the dashboard you get by default. So you can have stuff that's related to you, you can have stuff that's related to the team, we've got our burndown chart down here on the left automatically, you can add new work directly through this. So right now, it says we have no work items in progress. That's kind of suspicious. Let's go back to our board for a second, so go to Work, then Backlogs. Let's drag that to in progress, drag that to in progress, and now let's go back to our dashboard, reload it, and now we have two items that are in progress. You can also customize this, so come down here, say Edit Dashboard or Add Widget, let's scroll down a little bit, we've got Sprint Capacity, let's take this, let's add that in, let's take Sprint Overview, put that in, and that's pretty good. So now we can see information about our sprint, we can see information down here about how much work is left, we've got a bunch of stuff that's not started, we've got a bunch of stuff that's in progress. If you click on it, it takes you right into the Scrum board and there you go. That's a quick demo of visualizing your progress using dashboards. 
Summary
Alright, summary of what we talked about in this module. We were talking all about project management with VSTS. Basically, using the work item tracking system in Visual Studio team services to help us manage our work. So we started off with what is a work item. A work item is basically a piece of work that we are managing. There are various types of work items, product backlog item, task, bug, user story, feature, there is a bunch of things in there. They all represent different types of information that we might want to track as we're managing our project. From there, we did a bunch of demos about using work items and work item queries, then a whole bunch of demos about managing a project using Scrum and VSTS. So there you go, work item tracking. Project management with VSTS. Next up, let's talk about QA testing and QA test case management with VSTS. 
QA Testing and Defect Tracking with VSTS
Intro
Hey everybody. This is the QA Testing and Defect Tracking with VSTS module. Quick overview. I want to talk about something that I'm going to call new QA. It's a way that I want you to think about your QA testing process. It's going to be different and I think better than probably what a lot of you do already. After that, we're going to talk about test case management with VSTS. And then we'll dive in for a whole bunch of demos on QA testing and defect tracking with VSTS and a lot of that is going to be using extension for Chrome that helps to make your QA testing process a lot better and easier. Now as a disclaimer, it's a disclaimer that you've heard in other places in the course, this is an intro course. If you want the deep dive on this content, check out my DevOps Skills for Developers with Visual Studio and TFS 2017. Pretty much everything that's in that course applies to this course, except with a whole lot more detail. So let's dive in. 
New QA vs. Old QA
Okay, first off, let's start with some terminology. I'm going to be using some terms and some phrases and I just want to make sure that I'm super clear about what I'm talking about, especially if I happen to switch back and forth between what I'm saying. So if I say QA tester, I mean manual tester. If I say manual tester, I mean QA tester. So this is a person who is doing testing. If I say QA test or manual test, they're both the same thing. Manual test equal a test that a human is running, a human-run test. Also, if I say bug or if I say software defect or defect, they mean the same thing. So a bug is a software defect and it's a problem in the software. Alright, so terminology is complete. My goal in this clip is to talk about something that I'm going to, for lack of a better word, call new QA. So if I say new QA, I'm really thinking about this in opposition to how a lot of organizations do QA and I think that what they're doing, well they make mistakes and two of the mistakes that I see again and again, two huge mistakes, are number one teams leave testing until the end of a project or the end of an iteration, two, developers don't write unit tests. These two things are enormous and they really cause problems and this is a source of a lot of quality issues that happen inside of a project. Now at best, companies are doing these mistakes and it's because of fuzzy thinking. They're not thinking really clearly about what they're doing or why. But at worst, and I think that this happens a lot more often, it just represents a lack of respect for your testers. Now the fuzzy thinking and the lack of respect are kind of related, but it's helpful to clarify exactly why they're related. Testing doesn't fix bugs. Testing finds bugs. There is a huge difference between the two things. No amount of testing is going to add quality into your product. And it's helpful to remember that the testers didn't create the bugs. It's the developers who created the bugs. The testers are the ones who found them, developers have to go and remove them. And then at the end, the testers verify that the bugs are gone. So testing doesn't fix anything. Testing finds the problems. So that huge mistake number one, teams leave testing until the end of a project and of the iteration. This causes lots of problems because you think about quality at the end. So most companies do something like this. They do planning and requirements gathering, they'll do some design, they'll build the software, they'll test the software, and then they'll deploy. Well actually, that's not 100% accurate. Most companies really do something more like this. They plan, they get the requirements, they do the design, they build, they test the code, they panic because the code is not very good, there is a lot of bugs, there is a lot of problems, they go and fix the problems, they test again, they panic because it's still not very good, they fix the problems, they go off and test it again, they hope that it's good, and they deploy. Well actually, even that's not quite accurate. This is what most companies do. So they do their planning and the requirements, they do design, they build their software, they test their software, they panic because it's bad, they fix it, they test again, it's still bad, they panic again, they fix some more, they test again, they hope it's good, they deploy to production, they find their bugs in production, they panic even harder than the first time, they fix the bugs really, really fast, test again really, really fast, hope really, really hard, and deploy to production again. That sound familiar? Yeah. The problem here is that testing is happening at the end. So teams leave their testing until the end of the project or the iteration and while it's hard to recover because the problems are already in there and you've built on top of the problems and well, fixing bugs late, usually it's expensive, usually it's harder. Huge mistake number two, developers don't write unit tests. Now remember who put those bugs into the software. Hint, it wasn't the testers. Now there are multiple types of tests worth pointing this out, and testing in software is a layered defense. So layered defense, what do I mean by that? I mean, don't assume that one type of test is going to be enough. You're probably going to need or want to do a couple different kinds of testing in order to make sure that you actually have a good solid high quality product that doesn't have a whole lot of bugs in it. Now while we're talking about a layered defense, layered defense for testing is really important, a layered defense for software security is really important. And I think that one of the best books on software testing and software security actually has nothing to do with computers. It's a book called The Defense of Duffer's Drift. It's by Ernest Dunlop Swinton and it was written in 1904 and it's a book of military infantry tactics. It's a short book, it's not very long, and it's very readable and it follows the dreams, more like nightmares, of a fictional lieutenant backsight forethought. So it's actually, it's kind of a clever funny little book, and ultimately, it's all about a layered defense. Read this book, it'll help you with your software testing and your software security. Anyway, testing is a layered defense, which brings us to something that's commonly referred to as a testing pyramid. So there are multiple kinds of tests and I think at the bottom, the base of your pyramid is going to be unit tests, then you'll have integration test that bring all your code together and test it. You'll have manual QA tests and then maybe you'll have automated user interface tests. Those automated UI tests, I cover that in the other class. Now the thing about this pyramid is it doesn't, I think, represent what the most important thing is. So here is Ben's testing pyramid. I want you to do most of your stuff as unit tests, so unit tests are probably written by developers, do a little bit of automated integration testing, a little bit of manual QA testing, and then a tiny little bit of automated UI tests like selenium or coded UI. Now why do I think of it this way and why do I think it's important to write a lot of unit tests. Well if you write a lot of unit tests, then QA is going to tend to get a much higher quality application to test. Treat your QA people with respect, don't ship them garbage. Don't rely on them to tell you that your stuff is garbage. Ship them something that's high quality. And developers, well rely on unit tests to help you find and fix bugs. If you find and fix the bugs, then you're going to be shipping a higher quality product to the testers and they can spend more time on something called exploratory testing. So you might have noticed that your QA testers are really good at breaking things, and actually, it's not quite true. They're really good at finding creative ways that your application is broken. All that random banging on your application, that's exploratory testing. It's an awful lot like what your customers are going to do when they use your application. So it's better to have your QA testers do exploratory testing than your customers, right, because then it's embarrassing when your customers find bugs in the application. Here is what I want you to do for new QA. So you're going to do some stuff with requirements, which is going to be deciding what are we going to do as a team. Once you've decided what you're going to do, you're going to do some planning and design, answer the questions, how are we going to build what we've decided to build, how are we going to test what we've decided to build, and as part of that effort, create written QA test plans. So early in the delivery process, decide how you're going to test this stuff, which means focus on quality early and this is not only going to be an activity that your QA testers are going to do. Enlist your software developers in the creation of the QA test plans. Develop them together. If the developers understand the QA test plans better, they're going to develop better, higher quality software. Makes sense, right. Enlist them in the process. Next, you're going to build software every single day and you're going to test software every single day. So building software every day, write the code with unit test, have an automated build, run your unit tests as part of the automated build, and each time you check in your code or commit your code to the repository, run your automated tests. For this test every day, you're going to be QA-ing every day. You're going to do QA activities every single day, not just at the end. And your developers are going to run QA tests too, not just the QA testers, and the idea with this is that if the developers have a written QA test plan that they can run against their software when they're ready to check in, if they discover when they run the QA test plan that their stuff doesn't work, well they can fix it before they check in. Once again, focus on quality early. That results in a higher quality product that's being sent to the QA team. So the QA is basically just going to check to make sure the QA tests pass and they can spend more time on exploratory testing where they look for the funky little weird bugs that no one has ever thought of. Now even though I broke these two activities apart, the build and test, you're really going to do them simultaneously. If you think of these as two different activities, then you're going to tend to do the testing later. You're going to try absolutely as hard as you can to do these simultaneously so that you're not thinking about testing as something that happens afterwards. If you do testing as an afterthought, then quality is going to be an afterthought. If you think about testing early, then quality is going to be something you think about early. Quality will be something you bake in to the product, so do those activities simultaneously, and at the end, you'll do your deploys, but you'll be deploying with confidence. So requirements for new QA. You're going to have written QA test plans. They have to be written down. If they're not written down, they can't be shared by the team. These test plans are going to be co-designed by the team and developers are going to be able to run them before they check in their code. And something to try is going to be developers and testers sitting together at the same computer doing testing together. QA becomes more informal, but something that happens all the time, and those informal tests, well you can do testing of partially done features. Before the developers have built a whole of stuff, have QA take a look at it and say yeah, that works, or nah, that doesn't really work. Alright, so that's enough of me talking. Next up, let's do some demos of this stuff. 
Test Case Demo, Part 1: A Basic Test Case
Okay, so I'm going to do a bunch of demos, a series of demos about testing using VSTS and all these demos assume you're using the Test Manager extension. So if you go to marketplace.visualstudio.com, you'll find the Test Manager extension. You'll need to install it on your VSTS account and enable it for your user account. And if you're not sure how to do that, you can go back a few modules in this course to the getting started module and check out the clip called Demo: Managing User Licenses and VSTS Extensions. That clip shows you exactly what you need to know. So in this first demo, we're going to create some test cases using VSTS. Alright, let's start out by planning our sprint. So let's assume that we're planning Sprint 1 and this is building on top of the kind of stuff we did in the project management module. So let's say the product we're working on is the calculator, the web calculator, and the requirements that we're thinking of doing in Sprint 1 are going to be add 2 numbers and divide 2 numbers. So let's drag them into Sprint 1, and then click into Sprint 1, and then here is our board. So we're planning on doing two different requirements in this sprint, so add two numbers and divide two numbers. Now part of what I would like you to do is to do test case planning as part of your sprint. So when you've decided what the requirements are that you're going to do in that sprint, I want you to go to the Test hub and start recording your test cases. So let's go to the test hub now. So we can click on this test link right here and the first thing you're going to see is a message that says you can't create test cases without a test plan, click here to create a test plan, and helpfully enough, it gives you that link. You don't have to do it this way, but I tend to think of it as our test plan is a container with the testing effort and that testing effort relates to a sprint. So let's call it Sprint 1 Test Plan. Here's our test plan and it's empty. Okay, so now that we have our test plan, we can either come over here and say new test case, which will just create a test case that hangs directly off a test plan, or we can organize it a little better using something called a test suite. So let's come over here, we're going to choose new requirement base suite. This brings up a work item query, it looks better on a higher resolution screen, but let's click Run query and it shows us all the product backlog items that we have inside of this project. Now it's showing us all of them and we really just care about the ones that are in this sprint. So I come over here, click new clause, and build up this work item query to include iteration path. Then I'm going to choose Sprint 1 as our iteration path because that's what we're in, click Run query, and it shows us just the ones inside this sprint. I'm going to select both of them and then click Create suites. These test suites that we have right here, they just help us to keep our stuff organized. Now we're going to do this a little bit out of order. I'm going to show you what the completed application actually looks like. In real life, you wouldn't have the completed application. So here's the application, it's an online calculator. Type in two numbers, click Calculate, and then there is the result. So let's go create a test case for adding two numbers together. Come back over here to our test suite, click on calculator add two numbers, and then we'll come over here and we'll say new and then choose new test case. So this test case is going to be fairly simple, we'll call it Add Two Numbers. We're going to come down here and we're going to start providing the steps. Step number one, open a browser, step number two, navigate to the application, expected result, application should load. Next one is going to be enter a value for value 1, choose add as the operator, click the Calculate button, and the expected result on this is result should be displayed. And then, let's just say exit the app. Alright, so we've got seven steps right there. Let's click Save and close and there is our test case and we can see that now the calculator add two numbers suite has one test case under it. If we click on the divide two numbers, we see that it has nothing under it. Okay, so that's the first part of the demo. So we've created a test plan, a couple of requirement-based test suites and a test case, but right now, that test case is pretty vague, so it's a good start, but a test case should have a lot more detail. In the next demo, we're going to add that detail in. 
Test Case Demo, Part 2: More Detailed Test Case
The test case we have so far is a good start, but it's pretty vague, not a whole lot of detail there and what we're going to want is we want our testers to have exactly the detail of what they're supposed to do inside that test case. So let's go add some more detail to that test case. Now this test case is not real specific. What we probably want to do is we want to tell it exactly where to go. Navigate to the application at and then I'm going to say @url. Let's do the same thing for value 1. So let's say Enter value 1 and we'll say in the value 1 box. Let's come down here, let's do the same thing for value 2. And then for the click Calculate button, we'll change the expected result to be result should be @result. Alright, so these are little variables that we can use inside our test case, and if we click on this link right here, parameter values, we see that it's given us a place to put these values. So in url, let's paste in the URL that we want to go to, value 1, lets' say type in 2, for value 2, type in 3, and the result should be 5. When we go to actually run this test, those values will show up on the screen. So there is our test case for adding two numbers. Let's click Save and close. So now that I have that test case, I actually want to take pretty much what I've done and I want to reproduce that for the divide. So one thing that's really handy is you can right-click on this and choose Edit selected test cases in grid. I'm going to copy all these to the clipboard, so I'll select all the lines for our test, select all that stuff, press Ctrl+C to copy that, and now, let's come over to Calculator divide by two numbers. This time I'm going to say new test case using grid. Select that first box, hit Ctrl+V to paste, and now it's just copied that in and let's change this to be divide two numbers. Let's hit Save and now we've just created a test case for calculator divide by two numbers. But with dividing, we actually have the positive case and the negative case. So we want to make sure that we handle divide by 0. So let's copy all this stuff again, paste it one more time, divide two numbers handles, divide by 0, click Save, and we've got those two test cases. So let's go modify these things. So right now, we'll go into number 42, open up divide 2 numbers. We need to provide parameter values for these things, so the URL, value 1, value 2, and the result, paste in the URL for our application, value 1 will be 6, value 2 will be 3, the result should be 2, and we can have multiple iterations of this. Let's say that this is relevant to have different values in here. So we can do same URL, let's say 8 divided by 2 should be 4. And whatever the different values are, you reuse the same test case, but you'll do multiple iterations of it. Let's click Save and close. Let's populate the divide by 0, 8 divided by 0, and we don't need a result because it won't matter. So we'll come to the click the Calculate button step and we'll say we should get a warning about divide by 0. When we try to tab off of that, it says that it's going to get rid of the result field. Click OK because I don't need it. And I can click Save and Close and we just modified those tests. Let's come back over here and let's change the view from grid to list and there's our test plan, our test suites, and our test cases. 
Demo: Run a Test Case and Create a Video Recording
Alright, in that last demo, we created test cases. In this one, we're going to actually run these test cases and we're going to run them with a test extension for Chrome. Now this test extension, you don't have to use it, you can test using any browser you want, but if you add this extension in and you hook it up, you get some really nice features. So go to Chrome, add the extension in, and then that'll show up in your menu bar. If you click on it, you see a screen looks like this, then it connect it to your VSTS account, you're going to click on the gear icon, you'll enter your VSTS URL, click Next, then it's going to show you the team projects and the teams that are in your VSTS account, select the one you want, click Save, and then you're connected and you can go off and enjoy your testing effort. So let's dive on in and do some testing. So if you look up here, I've got the test extension, it's already connected, and it's connected to benday-VSTS-2018.visualstudio. I want to make sure it's connected to this project, so it's just going to be ps-web-calculator. I'll choose the ps-web-calculator team and click Save. Alright, so let's go ahead and run this test. We'll right-click on it and we have two different options. We can either do run test or run test with options. I'm going to choose run test with options because I want to choose what we're going to do. So we've got a bunch of different options on how we're going to run this test and what we're going to do is manual test using web browser-based runner, but you also have some other options in here which I'm not going to get into right now. You can choose which build you're running this against. This is my most recent build, I'm going to choose it, hit OK, hit OK again, and this shows me a Test Runner window that has all the steps I need and the values I need to test the application. Now one of the things that's nice is you can record yourself doing the testing. So if you click on this icon right here, you can do record screen. I have multiple monitors so I'm going to choose the screen that I'm working with right now, screen 1, and then it says that test and feedback is sharing your screen. So first step, open a browser, yep, that worked, so we'll check the little checkbox saying that step passed. Next thing is go to this URL, grab that value, put it in the clipboard, and let's come over here and paste it into our browser window. Let's change this so that it runs side by side with the test steps so that step 2, that passed as well. Click check, enter value 1 in the box for Value 1 and value 1 is going to be 6, tab off of that, that worked, pass that step, choose the add operator, that worked too. Value 2 is going to be 3, that worked okay. And then the last thing here is click the Calculate button, the result should be 2. So actually, I have a problem in my test. I've got the wrong operator in here. Since I know that my test is running fine, they just have the wrong thing in here, I can hover over this step and then click the Edit test step button, choose divide as the operator. Now let's come back over here, back down to click calculate, click it, and now that we have the right operator, we get the right result. We'll pass that and then exit the application. That worked too. We'll stop the recording and then we'll say save and close. Come back over to our test suite and we see that test passed. Now from here, we can go to test runs, so we'll click on Runs and here is the information on the test run we just did. We can double-click into it, go to Test results, double-click the test results, come down here to Iteration 1, Iteration 1 passed, shows us what we did, and we have a screen recording that's attached to that iteration. Download it, click on it, and here is the video of us doing our test case. Alright, so there you go, that is running our test cases using the web along with the Chrome extension that helps us do some fancy stuff. Next up, let me show you how to run your test case using the web and create a bug. 
Demo: Run a Test Case and Create a Bug with a Screenshot
Okay, in this demo, I'm going to show you how to run test cases using the web interface in VSTS, but then we're also going to create a bug. Alright, here we are in our test suite and let's say that we want to run the Divide two numbers handles divide by 0 test. I'm going to right-click and just say Run test. Opens up our test steps, we'll say yep, browser is good, let's copy this URL and open this up in a tab. That worked. We'll enter Value 1, that's going to be 8, choose our operator as divide and that passed and that passed. Value 2 is going to be 0 and now we'll click the Calculate button. So we click Calculate and let's just say that we should get a warning about divide by 0. We're getting a message, but we're not getting a warning and it's really kind of subtle. So let's say that we don't like this and we're going to say that this is a failure. So in this case, we'll mark this step as failing and we'll say warning is not obvious. And now if we want to really make this a little bit more clear in our bug because we're going to create a bug in a second, and we'll come up here and we're going to choose Capture Screenshot. It brings up a screenshot capture and let's just grab part of our screen, let's decorate it, let's draw an arrow, add a message, that's not visible enough, and we'll click check to save our screenshot. So that'll be on the failed step. And now, let's create a bug. Click Create bug and we'll say divide by 0 warning not visible enough. Now automatically it's taking those steps and putting them right into our defect, including the screenshot attachment. Pretty good, right. Click Save and Close, we'll save and close on the test execution, so click the Save and Close button, come back over to our test suite and we see that test has failed. Another way we can get to the result on that is we can right-click on it and say view test result. It takes us to the Run Explorer and we can see we have an attached bug, and if we look at the details, see our repro step steps including the screenshot that we created as part of executing that test and creating the bug. If we click into the bug, we can see that everything is all attached and all the detail is right in that bug, including system information about the system we were running when we encountered this problem. All that detail makes it much easier to go and fix the bug and reproduce the bug if you're a developer, fix it, get it done without having to do a whole lot of back and forth trying to figure out what actually happened. Another thing that would be helpful to create a really great bug would be if I video recorded myself doing it, but I didn't do it on this one. You might want to do that when you're running your test. So there you go, running a test case via the web and creating a bug. 
Summary
Okay, so let's do a wrap up of what we talked about in this module. So we started off by talking about what I'm calling new QA. The basic gist here is don't leave your QA effort, don't leave your testing effort, don't leave quality to be the last thing you think about when you're developing software. Think about it early, think about it while you're planning what to do and list your software developers in having a high-quality system from the very beginning so that it's not something that you just panic about at the very end. After that, I showed you a bunch of demos on how to do test case management with Visual Studio Team Services, including demos of doing QA testing and defect tracking using the web interface, specifically, using the Chrome extension so that you can create video recordings and screenshots right while you're testing right in the browser. Next up, let's do the last module in the course, which is going to be migrating existing projects and existing stuff into VSTS. 
Migrating Existing Projects to VSTS
Intro
Hey everybody. It is the last module of the course. This is the Migrating to VSTS module. Now here is an overview of what we're going to talk about in this module. This module is going to be kind of short. I'm just going to talk a little bit about how you might want to move your stuff to VSTS. Now if you're looking for a deeper dive on how to migrate to VSTS, you should check out Scott Tate's course Visual Studio Team Services Migrating from TFS. That's up in the Pluralsight library. He's got a ton of information, he's going to go way deeper into this stuff than we're going to in this course. So go check that out. That said, let's dive in for the rest of the course. 
Options for Migrating to VSTS
Alright, migrating to VSTS. You've got two options, simple or difficult. The simple version is pretty much just grab your stuff and go. Don't worry too much about what you're moving in, and in fact, try not to take too much stuff with you because it'll go a lot faster that way versus moving into VSTS where you really want to be thorough. Now here's a question. Does your project look kind of like this? It's just like a gigantic pile of stuff all over the place. You've got tons of source code that's just been hanging around for years or decades, tons of work items, tons of test cases, tons of builds, tons of just stuff hanging all over the place. Well if it looks like that, here's your chance to clean up. Try not to take everything with you. Try to think a little bit before you go to VSTS about what you really need. And when you're moving stuff to VSTS, there is levels of difficulty to think about. The simple version is just migrate version control, just take your version control stuff, take your code, and that's it. The less simple is version control plus work items, so taking some of your project plan, some of your test cases over, that adds some complexity. Then the hard one is a full VSTS migration. So take your TFS that you have running on-prem and push that into Visual Studio Team Services. Now some details on this. So the simple version control migration, just move your code, and assuming that it's Git or GitHub, this is crazy easy and you get to migrate your full history and you don't have to think too hard. Moving from Git to VSTS is going to be your easiest. Now if you're using Team Foundation Version Control, TFVC, my recommendation is to try to do a Get Latest Migration, which in a Get Latest migration, also known as a tip migration, all you're going to do is do a Get Latest and then take whatever the current version of the code is and push it into TFVC in VSTS. The downside here is that there is no history. The upside is it's very easy. Another option you have is to convert to Git before you move to TFVC. So in TFS, you can just right-click on your TFVC repository, convert it to Git, and then that'll do some magic behind the scenes to create a Git repository and then you can do a Git migration to the cloud. So you start in TFS and TFVC and you end up in VSTS using Git and that's pretty easy to do. The less simple option is to move your code and then you're going to move some of your work items. So work items meaning your project management, your features, your user stories and product backlog items, tasks, bugs, maybe move some test cases from the test hub. Now you can get a lot of stuff moved over, but it's not going to be perfect, and ultimately, it might not really be worth the effort to migrate your work items this way. It's going to be a lot of cut and paste, but if you've got a lot of detail beyond just the title and maybe some descriptions, this is going to be perhaps underwhelming to you. Now the full on hard migration, this is the full thing. You're going to take your TFS database and just move it all the way to VSTS and you're going to do this using the TFS Database Migrator tool. In the end, you're going to end up with a Visual Studio Team Services implementation that looks nearly identical to what you have in your on-premise TFS. If you decide you want to do it, you're going to download the Team Foundation Server to Visual Studio Team services migration guide from Microsoft and then you're going to want to read it probably a few times because it's pretty complicated. It's 60 pages of a lot of detail. Here's the basics of it. First off, you're going to need to take care of Azure Active Directory. You're probably using Active Directory on-prem right now, Well, you need to have some kind of replication up to Azure Active Directory because that's where your users are going to be. Then you're going to also have to upgrade TFS to a migratable version so that's probably going to be TFS 2017 or 2018. So FYI, if you're running a really old version of TFS, you're going to have to do an upgrade anyway before you can even migrate it to the cloud. So that just by itself might be a lot of work. Then there is the Migration Tool that comes from Microsoft. So you're going to validate your TFS, fix any problems the validator finds, then you're going to export your data, upload that data to Azure, and then run an import that'll import to VSTS. It's complex and it's a ton of work, and as a shameless plug, I'd be happy to help you out with this, just drop me a line. So that's enough of that shameless plug and that's the overview of your migration options. Next up, we'll do some demos and the first one we're going to do is we're going to take a Git repository and we're going to migrate it up to VSTS. 
Demo: Migrate from GitHub to VSTS
In this demo, I'm going to show you how to migrate a Git repository from GitHub to VSTS. Alright, so here we are on our VSTS account and let's create a brand-new project and this will be the project that we're going to populate with stuff from GitHub. So we'll click on the New Project button, give it a name, and I'm going to call this build utilities because this is what we're going to import. Choose Git as my version control and Scrum as my work item process and hit Create. Okay, so here we are on our New Project page, and if you scroll down a little bit, we've got an option right here that says import a repository. So if we open that up and click the Import button, it gives us a dialog that says Import a Git repository and it's asking us for the URL to pull from. So this can be any Git endpoint, but it has to be available to VSTS. So a Git endpoint that's on your local desktop machine probably wouldn't be visible to VSTS, but GitHub is. So I have a different tab open, which is my GitHub build-utilities project and I want to clone this and take all the history with it. So what we want to do is come over here to clone or download, and right here, we have the URL for the Git repository. So let's copy it to the clipboard and now we can go back over to VSTS, paste this in. If you need to log into your Git repository, you can check Requires authorization, and then put in a username and password or personal access token, but this is open, so I'm just going to click Import and there you go. The import was successful, it's pulled in that Git repository. So we can click on Navigate the code and we can see all the code that came from that Git repository, and if we click on History, we can get all the history for that Git repository as well. So let's pull the whole thing over from GitHub, it's not in VSTS. From this point, you just work with it like it's any other Git repository in VSTS. You can do a clone, you can do builds, anything you want to do, it's the same. Alright, so that's migrating a Git repository that is publicly available to VSTS. Next, I'm going to show you how to push a repository you might have in your local machine that wouldn't be visible to VSTS and push it up to VSTS and make it available there. 
Demo: Migrate from Git to VSTS
In this demo, I'm going to show you how to migrate a Git repository to VSTS and this can be any Git repository, it doesn't have to be publicly available. And we're going to do this using some command-line commands and well here are the commands we're going to use. So the first thing we want to do is take an existing Git repository and view what are known as the remotes. These are the remote repositories that you publish to when you will push your changes up to that server. So you'll go to the command line, you'll run git remote -v and then it'll show you the remotes that are hooked up to your repository. Chances are very high that there is going to be a remote called origin and that's one we'll want to deal with. Then we'll take the existing remote called origin and we're going to rename it to a new name. So that keeps the existing relationship, but just names it something else. Then we'll add a new remote and this one we're going to call origin again because we just renamed the old one, we'll create a new one called origin, we'll give it the new git url, and then we'll push our changes to that new remote, our new origin using git push origin master. So here we are, I've got a brand-new project in VSTS and this is the Pluralsight presidents-core project. This is the code that I used in my TFS 2017 DevOps course. Alright, so we've got our project and we've got the URL right here. This is the URL for our brand-new empty Git repository and we want to migrate up our code from an existing Git repository. So I'm going to open up a command prompt. Here is a command prompt and this is the code that we want to migrate. This is the repository we want to migrate. So the first thing we're going to do is we're going to look at what remotes we have currently. So we'll type in git remote -v and that shows us the URL for our current remote for this repository. So right now, this is Git hosted inside of a TFS virtual machine that's in Azure. It is not public to VSTS at all. So there is no way to just do that simple import that we did in the previous demo. So we have a remote called origin and we want to rename it something else. So we're going to type in git remote rename origin and then give it a new name and I'm going to call it old. Now let's run git remote -v again, and we can see that's been renamed to old. So let's add a new remote called origin and this is going to be the URL for VSTS. So let's go back over to that web page for a second, here's that URL, click copy to clipboard, come back over here and let's paste that in and hit Enter. Let's run git remote -v again and now we have an old and an origin. So let's go and push to origin. So we'll do that by issuing push origin master, so that says take the master branch and push it up to the remote called origin and there you go. Let's go back over to the web page. Let's hit code and now the code is up there. And if we click on History, we can see all the history for that code as well. So we just migrated our Git repository up to VSTS just using a handful of command-line commands and that not only migrated the code itself, but it also migrated the history. 
Demo: Migrate Code to TFVC
In this demo, I'm going to show you how to migrate a TFVC repository, Team Foundation Version Control. So we're going to take code that's in TFVC and we're going to put it into TFVC. So we're going from TFVC to TFVC. How many times can I say TFVC in 20 seconds? So we're going to take our TFVC repository that's in my on-premise TFS and we're going to push it up to a project that's TFVC in VSTS. Now, it's really important to point out that the way that I'm going to do this, there is no history being migrated at all. This is what's known as a tip migration or a get latest migration. So what I'm going to do is I'm going to do a get latest from TFVC and then push it up to TFVC in VSTS. That's it, nothing special. So really if you think about it, you can use this mode, this method of migration for any code or any version control system. It doesn't matter. It's simple, we're not migrating history, you just move code around, take it from one place, put it someplace else. So let's dive into the demo. So we're going to start off by creating a new project that has TFVC as the version control. So I'm just going to say my-tfvc-project, change version control to Team Foundation Version Control, and then hit Create. Here is the Landing Page. There is nothing in our project right now so let's go open this project up using Visual Studio. You have to set up your workspace first to the new project on whatever machine you're going to migrate from so that you build that relationship so you set up the relationship between your machine and the new TFVC project. So we're going to open up Visual Studio. Alright, here we are in Visual Studio and we need to go to Team Explorer and then we need to connect to that project that we just created in VSTS. We'll click on Manage Connections, then we'll click on Manage Connections again over here and say connect to a project. Alright, so we'll go to benday-VSTS-2018.visualstudio.com, and in here, we've got my-tfvc-project. So we'll click that and hit Connect. Next, we need to configure our workspace. I'm going to change this path to be C:\code\temp\my-tfvc-project and then I'm going to click Map and Get and now it's mapped. Okay, so let's click on Source Control Explorer. So this is our raw view into TFVC source control, and what we're going to do now is we're going to just migrate our code into this. So this right here is the directory that we mapped, so this is our local directory. So if we put code in here and then add it into TFVC, that'll be our migration process. So let's open up that folder. Right now, nothing in it, except for that BuildProcessTemplate that we got just by creating that new project. So we need to copy our code into this. So we're going to open up a new Explorer window and we're going to go to the folder that has the source code we want to migrate up to TFVC. Alright, so here we are. We've got the code we want to migrate, it's just HelloWorld, super simple. So what we'll do is we'll go to that directory we want to migrate, right-click it, choose Copy, and now let's go back to our TFVC window, here we are, and now we'll paste this code. We've copied the code, let's go into that and let's open that solution up. So we've got the HelloWorld solution, double-click it. Alright, here's that code and this is going to be really simple. So we've copied it into that directory, so this directory is mapped to our new TFVC project. So all we have to do is in Visual Studio, right-click, say Add solution to source control, and now right-click it again and say Check in, and let's give it a comment, Migrated hello world code to VSTS TFVC source control, then hit Check in. So now if we go back to the web interface for that. Here is the web interface. If we go to Code, there is our HelloWorld code. And let's go to History. History only has one check in, only one change set in here and it's because we just did all that migration in a single change set. So we're not migrating any existing history, we're just lifting it, dropping it into TFVC on VSTS. So you can use this with migrating any code from any version control provider. It's called a get latest migration. Do we get latest? Migrate the latest code, that's it. 
Summary and Thanks
Okay, brief summary of this module. We talked about how to move your stuff to VSTS. So mostly, I just showed you the basics of this. We talked about some of the options, how you can move things around, and then I did a couple demos showing you how to migrate GitHub to VSTS, git to VSTS, or a TFVC repository to VSTS. Basically, just try to think about taking as little stuff as you possibly can over to VSTS and that'll make your life a lot easier. But if you want to have a more complicated, you want to do a full fidelity migration, there is the TFS Migration Tools, but they take a lot of work and you might want some help on that. Anyway, thank you very much for watching this course. I hope you got a lot out of it. If you have any questions, feel free to contact me on Twitter or in the discussions for this class or find my email address and send me a line. I'd be happy to help out and answer any questions you might have. So thank you very much for watching.